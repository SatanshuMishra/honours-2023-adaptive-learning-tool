export const dummyData: {
  difficulty: number;
  question: string;
  code?: string;
  answers: string[];
  correct: number;
  explanations: string[];
  bloomTaxonomy: string;
  timeTakenSeconds: number;
  topic: string;
}[] = [
  {
    difficulty: 0.2,
    question: "What is the primary difference between a stack and a queue?",
    answers: [
      "A stack follows Last In First Out (LIFO) principle, while a queue follows First In First Out (FIFO) principle.",
      "A stack follows First In First Out (FIFO) principle, while a queue follows Last In First Out (LIFO) principle.",
      "A stack and a queue both follow Last In First Out (LIFO) principle.",
      "A stack and a queue both follow First In First Out (FIFO) principle.",
    ],
    correct: 0,
    explanations: [
      "A stack follows Last In First Out (LIFO) principle, meaning the last element added to the stack will be the first one to be removed. Whereas, a queue follows First In First Out (FIFO) principle, meaning the first element added to the queue will be the first one to be removed.",
      "This statement is incorrect because a stack does not follow the First In First Out (FIFO) principle; instead, it follows the Last In First Out (LIFO) principle.",
      "This statement is incorrect because both a stack and a queue do not follow the Last In First Out (LIFO) principle; only a stack does.",
      "This statement is incorrect because both a stack and a queue do not follow the First In First Out (FIFO) principle; only a queue does.",
    ],
    bloomTaxonomy: "Remembering",
    timeTakenSeconds: 30,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.4,
    question:
      "What data structure should be used to implement undo functionality in a text editor?",
    answers: ["Stack", "Queue", "ArrayList", "LinkedList"],
    correct: 0,
    explanations: [
      "A stack is the appropriate data structure for implementing undo functionality in a text editor. This is because the last action performed is the first to be undone, which aligns with the Last In First Out (LIFO) behavior of a stack.",
      "Using a queue for undo functionality is not appropriate because a queue follows the First In First Out (FIFO) principle, which is not suitable for undo operations.",
      "ArrayList does not provide the desired behavior for implementing undo functionality in a text editor because it does not inherently support the Last In First Out (LIFO) behavior required for undo operations.",
      "LinkedList does not provide the desired behavior for implementing undo functionality in a text editor because it does not inherently support the Last In First Out (LIFO) behavior required for undo operations.",
    ],
    bloomTaxonomy: "Remembering",
    timeTakenSeconds: 40,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.3,
    question:
      "Which method in the Java Stack class is used to retrieve and remove the element at the top of the stack?",
    answers: ["pop()", "peek()", "remove()", "get()"],
    correct: 0,
    explanations: [
      "The 'pop()' method in the Java Stack class is used to retrieve and remove the element at the top of the stack. It follows the Last In First Out (LIFO) principle of a stack.",
      "The 'peek()' method retrieves but does not remove the element at the top of the stack, so it is not used to retrieve and remove the element.",
      "The 'remove()' method in the Collection interface is not specific to stacks and doesn't remove the top element of the stack.",
      "The 'get()' method is not used for retrieving and removing elements in a stack. It's used in other data structures like ArrayList to get an element at a specified index.",
    ],
    bloomTaxonomy: "Remembering",
    timeTakenSeconds: 35,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.2,
    question: "In a queue, where are new elements typically added?",
    answers: [
      "At the rear",
      "At the front",
      "In the middle",
      "At random positions",
    ],
    correct: 0,
    explanations: [
      "In a queue, new elements are typically added at the rear. This adheres to the First In First Out (FIFO) behavior of queues, where the element that has been in the queue the longest is at the front.",
      "Adding new elements at the front of a queue would violate the First In First Out (FIFO) principle as it would disrupt the order of elements.",
      "Queues typically do not allow adding elements in the middle because it would disrupt the order of elements and violate the First In First Out (FIFO) principle.",
      "Adding elements at random positions is not a characteristic behavior of queues, which adhere to the First In First Out (FIFO) principle.",
    ],
    bloomTaxonomy: "Remembering",
    timeTakenSeconds: 25,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.5,
    question:
      "Which of the following is NOT a valid implementation of a queue in Java?",
    answers: ["ArrayList", "LinkedList", "Queue interface", "PriorityQueue"],
    correct: 0,
    explanations: [
      "While ArrayList and LinkedList are valid implementations of queues in Java, the Queue interface itself is not a concrete implementation but rather an interface. PriorityQueue is also a valid implementation of a queue.",
      "The Queue interface itself is not a concrete implementation but rather an interface. It defines the methods that a queue should have but does not provide a specific implementation.",
      "LinkedList is a valid implementation of a queue in Java, providing the necessary functionality to represent a queue.",
      "PriorityQueue is a valid implementation of a queue in Java, offering a priority-based ordering of elements.",
    ],
    bloomTaxonomy: "Remembering",
    timeTakenSeconds: 45,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.3,
    question:
      "Which of the following methods is used to add an element to the end of a queue in Java?",
    answers: ["offer()", "enqueue()", "add()", "push()"],
    correct: 0,
    explanations: [
      "The 'offer()' method in Java is used to add an element to the end of a queue. It is a part of the Queue interface and is commonly used for this purpose.",
      "The 'enqueue()' method is not a standard method in Java for adding elements to a queue.",
      "The 'add()' method is a general-purpose method for adding elements to collections, but it is not specific to queues.",
      "The 'push()' method is used for adding elements to a stack, not a queue.",
    ],
    bloomTaxonomy: "Remembering",
    timeTakenSeconds: 30,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.4,
    question:
      "What is the time complexity of the 'push' operation in a stack implemented using a LinkedList in Java?",
    answers: ["O(1)", "O(n)", "O(log n)", "O(n log n)"],
    correct: 0,
    explanations: [
      "The 'push' operation in a stack implemented using a LinkedList in Java has a time complexity of O(1). This is because LinkedList allows constant-time insertion at the beginning, which corresponds to the 'push' operation in a stack.",
      "The time complexity of the 'push' operation in a stack implemented using a LinkedList in Java is O(1), not O(n).",
      "The time complexity of the 'push' operation in a stack implemented using a LinkedList in Java is O(1), not O(log n).",
      "The time complexity of the 'push' operation in a stack implemented using a LinkedList in Java is O(1), not O(n log n).",
    ],
    bloomTaxonomy: "Remembering",
    timeTakenSeconds: 40,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.3,
    question:
      "Which method is used to retrieve but not remove the element at the front of a queue in Java?",
    answers: ["peek()", "poll()", "remove()", "pop()"],
    correct: 0,
    explanations: [
      "The 'peek()' method in Java is used to retrieve but not remove the element at the front of a queue. It returns the element at the head of the queue without removing it.",
      "The 'poll()' method is used to retrieve and remove the element at the front of a queue.",
      "The 'remove()' method is used to remove the specified element from a collection, not specifically for queues.",
      "The 'pop()' method is used to retrieve and remove the top element from a stack, not from a queue.",
    ],
    bloomTaxonomy: "Remembering",
    timeTakenSeconds: 35,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.5,
    question:
      "Which of the following is NOT a valid method to remove an element from a stack in Java?",
    answers: ["remove()", "pop()", "poll()", "None of the above"],
    correct: 0,
    explanations: [
      "The 'remove()' method is not a valid method to remove an element from a stack in Java. 'pop()' and 'poll()' are used for this purpose. 'remove()' is a method in the Collection interface used for removing elements based on their value.",
      "The 'pop()' method is used to remove and return the top element from a stack.",
      "The 'poll()' method is not a method in the Stack class. It's commonly used in queues.",
      "None of the above options are valid methods to remove an element from a stack.",
    ],
    bloomTaxonomy: "Remembering",
    timeTakenSeconds: 45,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.4,
    question:
      "What happens when you try to pop an element from an empty stack in Java?",
    answers: [
      "An EmptyStackException is thrown.",
      "A NullPointerException is thrown.",
      "An ArrayIndexOutOfBoundsException is thrown.",
      "The stack remains unchanged.",
    ],
    correct: 0,
    explanations: [
      "When you try to pop an element from an empty stack in Java, an EmptyStackException is thrown. This exception indicates that the stack is empty and there are no elements to pop.",
      "A NullPointerException is not thrown when trying to pop an element from an empty stack. EmptyStackException is the appropriate exception for this scenario.",
      "An ArrayIndexOutOfBoundsException is not thrown when trying to pop an element from an empty stack. EmptyStackException is the appropriate exception for this scenario.",
      "The stack remaining unchanged is not the expected behavior when trying to pop an element from an empty stack. An EmptyStackException is the appropriate exception for this scenario.",
    ],
    bloomTaxonomy: "Remembering",
    timeTakenSeconds: 40,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.4,
    question:
      "Which of the following statements is true about a LinkedList in Java?",
    answers: [
      "It implements both List and Queue interfaces.",
      "It implements only the List interface.",
      "It implements only the Queue interface.",
      "It implements neither List nor Queue interfaces.",
    ],
    correct: 0,
    explanations: [
      "A LinkedList in Java implements both the List and Queue interfaces. This means it can be used as a list (with ordered elements) and as a queue (with FIFO behavior) depending on the methods used.",
      "A LinkedList in Java actually implements both the List and Queue interfaces, not just the List interface.",
      "A LinkedList in Java actually implements both the List and Queue interfaces, not just the Queue interface.",
      "A LinkedList in Java actually implements both the List and Queue interfaces.",
    ],
    bloomTaxonomy: "Remembering",
    timeTakenSeconds: 40,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.3,
    question: "What is the purpose of the 'size()' method in Java collections?",
    answers: [
      "To return the number of elements in the collection.",
      "To add elements to the collection.",
      "To remove elements from the collection.",
      "To check if the collection is empty.",
    ],
    correct: 0,
    explanations: [
      "The 'size()' method in Java collections is used to return the number of elements in the collection. It provides information about the size or length of the collection.",
      "The 'size()' method in Java collections does not add elements to the collection; it returns the number of elements.",
      "The 'size()' method in Java collections does not remove elements from the collection; it returns the number of elements.",
      "The 'size()' method in Java collections does not check if the collection is empty; it returns the number of elements.",
    ],
    bloomTaxonomy: "Remembering",
    timeTakenSeconds: 35,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.4,
    question:
      "Which of the following statements regarding ArrayList and LinkedList in Java is true?",
    answers: [
      "ArrayList is more suitable for random access, while LinkedList is more efficient for insertions and deletions.",
      "LinkedList is more suitable for random access, while ArrayList is more efficient for insertions and deletions.",
      "Both ArrayList and LinkedList have the same performance characteristics for random access and insertions/deletions.",
      "Neither ArrayList nor LinkedList are suitable for random access or efficient for insertions and deletions.",
    ],
    correct: 0,
    explanations: [
      "ArrayList is more suitable for random access because it implements an array internally, allowing direct access to elements by index. LinkedList is more efficient for insertions and deletions, especially in the middle of the list, because it doesn't require shifting elements as ArrayList does.",
      "LinkedList is actually more efficient for insertions and deletions, especially in the middle of the list, because it doesn't require shifting elements as ArrayList does. ArrayList is more suitable for random access because it implements an array internally.",
      "ArrayList is actually more suitable for random access because it implements an array internally, allowing direct access to elements by index. LinkedList is more efficient for insertions and deletions, especially in the middle of the list, because it doesn't require shifting elements as ArrayList does.",
      "ArrayList and LinkedList have different performance characteristics. ArrayList is more suitable for random access due to its internal array implementation, while LinkedList is more efficient for insertions and deletions due to its node-based structure.",
    ],
    bloomTaxonomy: "Remembering",
    timeTakenSeconds: 40,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.3,
    question:
      "Which of the following Java collections allows duplicate elements?",
    answers: ["List", "Set", "Queue", "Map"],
    correct: 0,
    explanations: [
      "The 'List' interface in Java allows duplicate elements. Lists are ordered collections that allow elements to be added at specific indices, and they can contain duplicate values.",
      "The 'List' interface in Java does allow duplicate elements, unlike some other collection types like Set.",
      "Sets in Java do not allow duplicate elements; however, Lists do.",
      "Queues and Maps in Java do not allow duplicate elements; however, Lists do.",
    ],
    bloomTaxonomy: "Remembering",
    timeTakenSeconds: 35,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.4,
    question:
      "Which of the following is true about the 'add()' method in Java ArrayList?",
    answers: [
      "It appends the specified element to the end of the list.",
      "It inserts the specified element at the specified position in the list.",
      "It removes the specified element from the list.",
      "It retrieves the specified element from the list.",
    ],
    correct: 0,
    explanations: [
      "The 'add()' method in Java ArrayList appends the specified element to the end of the list. It adds the element at the end, increasing the size of the list by one.",
      "The 'add()' method in Java ArrayList does not insert the specified element at a specified position; that behavior is handled by the 'add(int index, E element)' method.",
      "The 'add()' method in Java ArrayList does not remove elements from the list; that behavior is handled by methods like 'remove(Object obj)' or 'remove(int index)'.",
      "The 'add()' method in Java ArrayList does not retrieve elements from the list; that behavior is handled by methods like 'get(int index)'.",
    ],
    bloomTaxonomy: "Remembering",
    timeTakenSeconds: 40,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.3,
    question:
      "What happens when you try to remove an element from an empty queue in Java using the 'remove()' method?",
    answers: [
      "A NoSuchElementException is thrown.",
      "A NullPointerException is thrown.",
      "An ArrayIndexOutOfBoundsException is thrown.",
      "The queue remains unchanged.",
    ],
    correct: 0,
    explanations: [
      "When you try to remove an element from an empty queue in Java using the 'remove()' method, a NoSuchElementException is thrown. This indicates that there are no elements in the queue to remove.",
      "A NullPointerException is not thrown when trying to remove an element from an empty queue using the 'remove()' method; a NoSuchElementException is thrown instead.",
      "An ArrayIndexOutOfBoundsException is not thrown when trying to remove an element from an empty queue using the 'remove()' method; a NoSuchElementException is thrown instead.",
      "The queue does not remain unchanged when trying to remove an element from an empty queue using the 'remove()' method; a NoSuchElementException is thrown instead.",
    ],
    bloomTaxonomy: "Remembering",
    timeTakenSeconds: 35,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.5,
    question:
      "Which method is used to remove and return the element at the front of a queue in Java?",
    answers: ["poll()", "peek()", "dequeue()", "remove()"],
    correct: 0,
    explanations: [
      "The 'poll()' method in Java is used to remove and return the element at the front of a queue. It retrieves and removes the head of the queue, or returns null if the queue is empty.",
      "The 'peek()' method in Java is used to retrieve but not remove the element at the front of a queue.",
      "The 'dequeue()' method is not a standard method in Java for removing elements from a queue; 'poll()' is used for this purpose.",
      "The 'remove()' method in Java is not specific to queues; it's a method in the Collection interface used for removing elements based on their value.",
    ],
    bloomTaxonomy: "Remembering",
    timeTakenSeconds: 45,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.3,
    question:
      "Which of the following is true about the 'isEmpty()' method in Java collections?",
    answers: [
      "It returns true if the collection contains no elements.",
      "It returns true if the collection contains one or more elements.",
      "It adds elements to the collection.",
      "It removes elements from the collection.",
    ],
    correct: 0,
    explanations: [
      "The 'isEmpty()' method in Java collections returns true if the collection contains no elements. It provides a way to check if the collection is empty or not.",
      "The 'isEmpty()' method in Java collections does not return true if the collection contains one or more elements; it returns true only if the collection contains no elements.",
      "The 'isEmpty()' method in Java collections does not add elements to the collection; it checks if the collection is empty.",
      "The 'isEmpty()' method in Java collections does not remove elements from the collection; it checks if the collection is empty.",
    ],
    bloomTaxonomy: "Remembering",
    timeTakenSeconds: 35,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.4,
    question:
      "Which of the following methods is used to add an element to the front of a queue in Java?",
    answers: ["add()", "offer()", "enqueue()", "push()"],
    correct: 0,
    explanations: [
      "The 'offer()' method in Java is used to add an element to the end of a queue, not the front. There is no direct method to add an element to the front of a queue in Java collections.",
      "The 'add()' method in Java collections adds elements to the end of the collection, not the front.",
      "The 'enqueue()' method is not a standard method in Java for adding elements to a queue; 'offer()' is used for this purpose.",
      "The 'push()' method is used for adding elements to a stack, not a queue.",
    ],
    bloomTaxonomy: "Remembering",
    timeTakenSeconds: 40,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.3,
    question:
      "Which method in Java Stack class is used to check if the stack is empty?",
    answers: ["empty()", "isEmpty()", "hasElements()", "nonEmpty()"],
    correct: 1,
    explanations: [
      "The 'isEmpty()' method in Java Stack class is used to check if the stack is empty. It returns true if the stack contains no elements; otherwise, it returns false.",
      "The 'isEmpty()' method in Java Stack class is the correct method for checking if the stack is empty.",
      "The 'hasElements()' method is not a standard method in Java for checking if a stack has elements.",
      "The 'nonEmpty()' method is not a standard method in Java for checking if a stack is not empty.",
    ],
    bloomTaxonomy: "Remembering",
    timeTakenSeconds: 35,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.3,
    question:
      "Which of the following data structures is most appropriate for implementing a LIFO (Last In First Out) behavior?",
    answers: ["Stack", "Queue", "ArrayList", "LinkedList"],
    correct: 0,
    explanations: [
      "A Stack data structure is most appropriate for implementing a LIFO (Last In First Out) behavior. It ensures that the last element added to the stack is the first one to be removed.",
      "A Stack, not a Queue, is designed to implement a Last In First Out (LIFO) behavior.",
      "ArrayList and LinkedList do not inherently implement a Last In First Out (LIFO) behavior like a Stack does.",
      "LinkedList does not guarantee a Last In First Out (LIFO) behavior as it is not specifically designed for that purpose.",
    ],
    bloomTaxonomy: "Remembering",
    timeTakenSeconds: 30,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.4,
    question:
      "Which method in Java LinkedList class is used to add an element to the end of the list?",
    answers: ["addLast()", "addFirst()", "insert()", "append()"],
    correct: 0,
    explanations: [
      "The 'addLast()' method in Java LinkedList class is used to add an element to the end of the list. It appends the specified element to the end of this list.",
      "The 'addLast()' method specifically adds an element to the end of the LinkedList, not at the beginning.",
      "The 'addLast()' method is used to add elements to the end of the LinkedList, not to insert them at arbitrary positions.",
      "There is no 'append()' method in the LinkedList class; 'addLast()' is used to add elements to the end of the list.",
    ],
    bloomTaxonomy: "Remembering",
    timeTakenSeconds: 40,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.3,
    question:
      "Which Java interface represents an ordered collection and allows duplicate elements?",
    answers: ["List", "Set", "Map", "Queue"],
    correct: 0,
    explanations: [
      "The 'List' interface in Java represents an ordered collection and allows duplicate elements. It maintains the insertion order of elements.",
      "The 'List' interface allows duplicate elements and maintains insertion order, unlike Set which does not allow duplicates.",
      "Lists, not Sets or Maps, represent ordered collections in Java.",
      "The 'Queue' interface represents a collection designed for FIFO (First In First Out) behavior and does not necessarily maintain insertion order.",
    ],
    bloomTaxonomy: "Remembering",
    timeTakenSeconds: 35,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.4,
    question:
      "Which of the following is true about the 'remove()' method in Java ArrayList?",
    answers: [
      "It removes the element at the specified position in the list.",
      "It removes the first occurrence of the specified element from the list.",
      "It retrieves the element at the specified position in the list.",
      "It adds the specified element to the list.",
    ],
    correct: 0,
    explanations: [
      "The 'remove()' method in Java ArrayList removes the element at the specified position in the list. It shifts any subsequent elements to the left (subtracts one from their indices) if applicable.",
      "The 'remove()' method does not remove the first occurrence of the specified element; that behavior is handled by 'remove(Object obj)' method.",
      "The 'remove()' method does not retrieve the element at the specified position; that behavior is handled by 'get(int index)' method.",
      "The 'remove()' method does not add elements to the list; it removes them.",
    ],
    bloomTaxonomy: "Remembering",
    timeTakenSeconds: 40,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.3,
    question:
      "What is the main advantage of using a LinkedList over an ArrayList in Java?",
    answers: [
      "Efficient insertion and deletion operations.",
      "Better random access performance.",
      "Lower memory consumption.",
      "More predictable performance in all scenarios.",
    ],
    correct: 0,
    explanations: [
      "The main advantage of using a LinkedList over an ArrayList in Java is its efficient insertion and deletion operations, especially in the middle of the list. LinkedList does not require shifting elements as ArrayList does.",
      "LinkedLists have efficient insertion and deletion operations, but they do not offer better random access performance compared to ArrayLists.",
      "LinkedLists do not necessarily have lower memory consumption compared to ArrayLists.",
      "LinkedLists may have more predictable performance in certain scenarios, but their main advantage lies in efficient insertion and deletion operations.",
    ],
    bloomTaxonomy: "Remembering",
    timeTakenSeconds: 35,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.4,
    question:
      "Which method in Java Stack class is used to retrieve but not remove the element at the top of the stack?",
    answers: ["peek()", "pop()", "top()", "get()"],
    correct: 0,
    explanations: [
      "The 'peek()' method in Java Stack class is used to retrieve but not remove the element at the top of the stack. It returns the element at the top of the stack without removing it.",
      "The 'peek()' method specifically retrieves the top element of the stack without removing it.",
      "The 'pop()' method removes and retrieves the top element of the stack; it does not just retrieve it.",
      "There is no 'top()' or 'get()' method in the Stack class for retrieving elements without removing them.",
    ],
    bloomTaxonomy: "Remembering",
    timeTakenSeconds: 40,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.3,
    question:
      "Which of the following Java collections maintains the insertion order?",
    answers: ["LinkedList", "HashSet", "TreeSet", "HashMap"],
    correct: 0,
    explanations: [
      "The 'LinkedList' class in Java maintains the insertion order of elements. Elements are appended to the end of the list in the order they are added.",
      "LinkedList maintains the insertion order, unlike HashSet which does not guarantee any specific order.",
      "TreeSet orders elements according to their natural ordering or a specified comparator, but it does not maintain the insertion order.",
      "HashMap does not maintain the insertion order of its elements.",
    ],
    bloomTaxonomy: "Remembering",
    timeTakenSeconds: 35,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.4,
    question:
      "What is the time complexity of the 'remove' operation in a LinkedList in Java?",
    answers: ["O(1)", "O(n)", "O(log n)", "O(n log n)"],
    correct: 1,
    explanations: [
      "The 'remove' operation in a LinkedList in Java has a time complexity of O(n). This is because removing an element requires traversing the list to find the element to remove, which can take linear time.",
      "The 'remove' operation in a LinkedList is not constant time (O(1)) but linear time (O(n)) because it may need to traverse the list to find the element to remove.",
      "The 'remove' operation in a LinkedList is not logarithmic time (O(log n)) but linear time (O(n)) because it traverses the list.",
      "The 'remove' operation in a LinkedList is not O(n log n) time complexity but linear time (O(n)).",
    ],
    bloomTaxonomy: "Remembering",
    timeTakenSeconds: 40,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.3,
    question:
      "Which method in Java Stack class is used to push an element onto the stack?",
    answers: ["push()", "add()", "append()", "insert()"],
    correct: 0,
    explanations: [
      "The 'push()' method in Java Stack class is used to push an element onto the stack. It adds the element to the top of the stack.",
      "The 'push()' method specifically adds an element to the top of the stack.",
      "There is no 'add()' or 'append()' method in the Stack class for adding elements onto the stack.",
      "There is no 'insert()' method in the Stack class for adding elements onto the stack.",
    ],
    bloomTaxonomy: "Remembering",
    timeTakenSeconds: 35,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.4,
    question:
      "Which of the following statements regarding the 'size()' method in Java collections is correct?",
    answers: [
      "It returns the number of elements in the collection.",
      "It adds elements to the collection.",
      "It removes elements from the collection.",
      "It checks if the collection is empty.",
    ],
    correct: 0,
    explanations: [
      "The 'size()' method in Java collections returns the number of elements in the collection. It provides information about the size or length of the collection.",
      "The 'size()' method does not add elements to the collection; it returns the number of elements.",
      "The 'size()' method does not remove elements from the collection; it returns the number of elements.",
      "The 'size()' method does not check if the collection is empty; it returns the number of elements.",
    ],
    bloomTaxonomy: "Remembering",
    timeTakenSeconds: 40,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.5,
    question:
      "What are the differences between ArrayList and LinkedList in Java?",
    answers: [
      "ArrayList uses dynamic arrays internally, while LinkedList uses doubly linked lists.",
      "ArrayList allows fast random access, while LinkedList is more efficient for insertions and deletions.",
      "ArrayList is synchronized, while LinkedList is not synchronized.",
      "All of the above.",
    ],
    correct: 3,
    explanations: [
      "All of the options provided are differences between ArrayList and LinkedList in Java. ArrayList uses dynamic arrays internally, allowing fast random access but less efficient insertions and deletions. LinkedList, on the other hand, uses doubly linked lists, making it more efficient for insertions and deletions but slower for random access. Additionally, ArrayList is synchronized, while LinkedList is not.",
      "The provided options correctly identify differences between ArrayList and LinkedList in Java. Each option highlights a specific characteristic or behavior unique to either ArrayList or LinkedList.",
      "The options provided accurately represent differences between ArrayList and LinkedList in Java. Each option describes a distinct aspect of the two data structures.",
      "The provided options correctly identify differences between ArrayList and LinkedList in Java. Each option highlights a specific characteristic or behavior unique to either ArrayList or LinkedList.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 45,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.6,
    question:
      "Explain the concept of a queue in Java and provide an example scenario where it can be used.",
    answers: [
      "A queue in Java is a data structure that follows the First In First Out (FIFO) principle.",
      "An example scenario where a queue can be used is in a print spooler, where print jobs are queued up and processed in the order they were received.",
      "A queue in Java allows elements to be added and removed from both ends.",
      "None of the above.",
    ],
    correct: 1,
    explanations: [
      "A queue in Java is indeed a data structure that follows the First In First Out (FIFO) principle, meaning the first element added to the queue will be the first one to be removed. An example scenario where a queue can be used is in a print spooler, where print jobs are queued up and processed in the order they were received.",
      "The explanation correctly identifies a queue in Java as adhering to the FIFO principle and provides a real-world scenario illustrating its usage.",
      "The explanation accurately defines a queue in Java and offers a practical example showcasing its application.",
      "The explanation effectively describes a queue in Java and provides an example scenario demonstrating its use.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 50,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.6,
    question:
      "How does a stack differ from a queue in terms of behavior and usage?",
    answers: [
      "A stack follows the Last In First Out (LIFO) principle, while a queue follows the First In First Out (FIFO) principle.",
      "A stack is more suitable for undo functionality, while a queue is more appropriate for managing tasks in the order they are received.",
      "A stack allows elements to be added and removed from both ends, while a queue only allows elements to be added at one end and removed from the other end.",
      "None of the above.",
    ],
    correct: 0,
    explanations: [
      "A stack indeed follows the Last In First Out (LIFO) principle, meaning the last element added to the stack will be the first one to be removed. On the other hand, a queue follows the First In First Out (FIFO) principle, meaning the first element added to the queue will be the first one to be removed.",
      "The explanation accurately distinguishes between the behaviors of a stack and a queue, highlighting their respective principles of operation.",
      "The explanation effectively contrasts the behaviors of a stack and a queue, illustrating their distinct characteristics.",
      "The explanation precisely explains the differences in behavior between a stack and a queue, emphasizing their opposing principles of operation.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 50,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.6,
    question:
      "Discuss the advantages and disadvantages of using a LinkedList over an ArrayList in Java.",
    answers: [
      "Advantage: Efficient insertions and deletions. Disadvantage: Slower random access.",
      "Advantage: Faster random access. Disadvantage: Inefficient insertions and deletions.",
      "Advantage: Synchronization. Disadvantage: Lack of support for generics.",
      "Advantage: Lower memory consumption. Disadvantage: Higher time complexity for operations.",
    ],
    correct: 0,
    explanations: [
      "Using a LinkedList over an ArrayList in Java provides the advantage of efficient insertions and deletions, especially in the middle of the list. However, it comes with the disadvantage of slower random access compared to ArrayList, which uses dynamic arrays internally for fast random access.",
      "The explanation effectively outlines the advantages and disadvantages of using a LinkedList over an ArrayList, emphasizing their trade-offs in terms of performance.",
      "The explanation accurately discusses the pros and cons of using a LinkedList over an ArrayList, highlighting their respective strengths and weaknesses.",
      "The explanation precisely details the advantages and disadvantages of choosing a LinkedList over an ArrayList, providing insight into their performance characteristics.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 50,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.6,
    question:
      "Explain the concept of a stack in Java and provide an example scenario where it can be used.",
    answers: [
      "A stack in Java is a data structure that follows the Last In First Out (LIFO) principle.",
      "An example scenario where a stack can be used is in managing function calls in a program, where each function call is pushed onto the stack and popped off when it returns.",
      "A stack in Java allows elements to be added and removed from both ends.",
      "None of the above.",
    ],
    correct: 1,
    explanations: [
      "A stack in Java indeed follows the Last In First Out (LIFO) principle, meaning the last element added to the stack will be the first one to be removed. An example scenario where a stack can be used is in managing function calls in a program, where each function call is pushed onto the stack and popped off when it returns.",
      "The explanation accurately defines a stack in Java and provides a real-world example demonstrating its usage, showcasing its applicability in managing function calls.",
      "The explanation effectively describes the characteristics of a stack in Java and offers a practical scenario illustrating its use in managing function calls.",
      "The explanation precisely explains the concept of a stack in Java and provides an example scenario demonstrating its usage in managing function calls.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 50,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.5,
    question:
      "Compare and contrast the performance characteristics of ArrayList and LinkedList in Java.",
    answers: [
      "ArrayList provides faster random access but slower insertions and deletions, while LinkedList offers efficient insertions and deletions but slower random access.",
      "ArrayList and LinkedList have identical performance characteristics in terms of random access and insertions/deletions.",
      "LinkedList provides faster random access but slower insertions and deletions, while ArrayList offers efficient insertions and deletions but slower random access.",
      "None of the above.",
    ],
    correct: 0,
    explanations: [
      "ArrayList does indeed provide faster random access due to its dynamic array implementation, but it's slower for insertions and deletions as it may require resizing the array and shifting elements. LinkedList, on the other hand, offers efficient insertions and deletions as elements can be easily added or removed without shifting, but it's slower for random access as it requires traversing the list.",
      "The explanation effectively compares and contrasts the performance characteristics of ArrayList and LinkedList, highlighting their strengths and weaknesses in terms of random access and insertions/deletions.",
      "The explanation accurately outlines the performance differences between ArrayList and LinkedList, emphasizing their trade-offs in terms of efficiency for random access and insertions/deletions.",
      "The explanation precisely details the performance characteristics of ArrayList and LinkedList, providing insight into their respective advantages and disadvantages.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 45,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.6,
    question: "Discuss the characteristics and usage of a Queue in Java.",
    answers: [
      "A Queue in Java follows the First In First Out (FIFO) principle and is commonly used for tasks such as job scheduling, print spooling, and network data packets.",
      "A Queue in Java follows the Last In First Out (LIFO) principle and is commonly used for undo functionality and managing function calls.",
      "A Queue in Java allows elements to be added and removed from both ends.",
      "None of the above.",
    ],
    correct: 0,
    explanations: [
      "A Queue in Java indeed follows the First In First Out (FIFO) principle, meaning the first element added to the queue will be the first one to be removed. It is commonly used for tasks such as job scheduling, print spooling, and managing network data packets.",
      "The explanation accurately describes the characteristics and usage of a Queue in Java, highlighting its adherence to the FIFO principle and providing examples of common applications.",
      "The explanation effectively discusses the properties and applications of a Queue in Java, emphasizing its utility in scenarios such as job scheduling, print spooling, and managing network data packets.",
      "The explanation precisely explains the characteristics and usage of a Queue in Java, providing insight into its behavior and practical applications.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 50,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.5,
    question:
      "Explain the concept of an ArrayList in Java and provide an example scenario where it can be used.",
    answers: [
      "An ArrayList in Java is a dynamic array that automatically resizes itself when needed.",
      "An example scenario where an ArrayList can be used is in managing a list of students in a classroom, where students can be added, removed, and searched for by index.",
      "An ArrayList in Java follows the First In First Out (FIFO) principle.",
      "None of the above.",
    ],
    correct: 1,
    explanations: [
      "An ArrayList in Java indeed is a dynamic array that automatically resizes itself when needed. An example scenario where an ArrayList can be used is in managing a list of students in a classroom, where students can be added, removed, and searched for by index.",
      "The explanation accurately defines an ArrayList in Java and provides a real-world example illustrating its usage in managing a list of students in a classroom.",
      "The explanation effectively describes the concept of an ArrayList in Java and offers a practical scenario demonstrating its use in managing a list of students in a classroom.",
      "The explanation precisely explains the characteristics of an ArrayList in Java and provides an example scenario showcasing its application in managing a list of students in a classroom.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 45,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.5,
    question:
      "Explain the concept of a LinkedList in Java and provide an example scenario where it can be used.",
    answers: [
      "A LinkedList in Java is a doubly linked list where each element points to the next and previous elements.",
      "An example scenario where a LinkedList can be used is in implementing a music playlist, where each song node points to the next and previous songs.",
      "A LinkedList in Java follows the Last In First Out (LIFO) principle.",
      "None of the above.",
    ],
    correct: 1,
    explanations: [
      "A LinkedList in Java indeed is a doubly linked list where each element points to the next and previous elements. An example scenario where a LinkedList can be used is in implementing a music playlist, where each song node points to the next and previous songs.",
      "The explanation accurately defines a LinkedList in Java and provides a real-world example demonstrating its usage in implementing a music playlist.",
      "The explanation effectively describes the concept of a LinkedList in Java and offers a practical scenario illustrating its use in implementing a music playlist.",
      "The explanation precisely explains the characteristics of a LinkedList in Java and provides an example scenario showcasing its application in implementing a music playlist.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 45,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.5,
    question: "What are the key characteristics of a stack in Java?",
    answers: [
      "A stack in Java follows the Last In First Out (LIFO) principle and allows elements to be added and removed from both ends.",
      "A stack in Java follows the First In First Out (FIFO) principle and is commonly used for tasks such as job scheduling and print spooling.",
      "A stack in Java is a dynamic array that automatically resizes itself when needed.",
      "None of the above.",
    ],
    correct: 0,
    explanations: [
      "A stack in Java indeed follows the Last In First Out (LIFO) principle, meaning the last element added to the stack will be the first one to be removed. It allows elements to be added and removed from the top (end) of the stack.",
      "The explanation accurately describes the key characteristics of a stack in Java, emphasizing its adherence to the LIFO principle and its behavior regarding element addition and removal.",
      "The explanation effectively outlines the essential properties of a stack in Java, highlighting its principle of operation and the manner in which elements are added and removed.",
      "The explanation precisely explains the fundamental characteristics of a stack in Java, providing insight into its behavior and usage.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 45,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.3,
    question: "What is the main characteristic of a queue in Java?",
    answers: [
      "Follows the First In First Out (FIFO) principle.",
      "Follows the Last In First Out (LIFO) principle.",
      "Allows elements to be added and removed from both ends.",
      "Automatically resizes itself when needed.",
    ],
    correct: 0,
    explanations: [
      "The main characteristic of a queue in Java is that it follows the First In First Out (FIFO) principle. This means that the first element added to the queue will be the first one to be removed.",
      "The other options are incorrect because queues do not follow the Last In First Out (LIFO) principle.",
      "The other options are incorrect because queues do not allow elements to be added and removed from both ends.",
      "The other options are incorrect because queues do not automatically resize themselves when needed.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 30,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.3,
    question:
      "Which data structure is best suited for managing function calls in a program?",
    answers: ["Stack", "Queue", "ArrayList", "LinkedList"],
    correct: 0,
    explanations: [
      "The data structure best suited for managing function calls in a program is a stack. It follows the Last In First Out (LIFO) principle, making it suitable for managing function calls where the last called function should be executed first.",
      "The other options are incorrect because stacks, unlike queues, ArrayLists, and LinkedLists, follow the Last In First Out (LIFO) principle.",
      "The other options are incorrect because stacks, unlike queues, ArrayLists, and LinkedLists, follow the Last In First Out (LIFO) principle.",
      "The other options are incorrect because stacks, unlike queues, ArrayLists, and LinkedLists, follow the Last In First Out (LIFO) principle.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 30,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.3,
    question: "What is the key characteristic of a stack in Java?",
    answers: [
      "Follows the Last In First Out (LIFO) principle.",
      "Follows the First In First Out (FIFO) principle.",
      "Allows elements to be added and removed from both ends.",
      "Automatically resizes itself when needed.",
    ],
    correct: 0,
    explanations: [
      "The key characteristic of a stack in Java is that it follows the Last In First Out (LIFO) principle. This means that the last element added to the stack will be the first one to be removed.",
      "The other options are incorrect because stacks do not follow the First In First Out (FIFO) principle.",
      "The other options are incorrect because stacks do not allow elements to be added and removed from both ends.",
      "The other options are incorrect because stacks do not automatically resize themselves when needed.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 30,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.3,
    question:
      "Which Java data structure is most suitable for managing print jobs in a printer queue?",
    answers: ["Queue", "Stack", "ArrayList", "LinkedList"],
    correct: 0,
    explanations: [
      "The Java data structure most suitable for managing print jobs in a printer queue is a queue. Print jobs are typically processed in the order they are received, which follows the First In First Out (FIFO) principle.",
      "The other options are incorrect because stacks, ArrayLists, and LinkedLists do not follow the First In First Out (FIFO) principle like queues do.",
      "The other options are incorrect because stacks, ArrayLists, and LinkedLists do not follow the First In First Out (FIFO) principle like queues do.",
      "The other options are incorrect because stacks, ArrayLists, and LinkedLists do not follow the First In First Out (FIFO) principle like queues do.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 30,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.3,
    question:
      "Which data structure in Java is best suited for implementing an undo feature in a text editor?",
    answers: ["Stack", "Queue", "ArrayList", "LinkedList"],
    correct: 0,
    explanations: [
      "The data structure best suited for implementing an undo feature in a text editor is a stack. It allows operations to be undone in the reverse order they were performed, which follows the Last In First Out (LIFO) principle.",
      "The other options are incorrect because stacks, unlike queues, ArrayLists, and LinkedLists, follow the Last In First Out (LIFO) principle.",
      "The other options are incorrect because stacks, unlike queues, ArrayLists, and LinkedLists, follow the Last In First Out (LIFO) principle.",
      "The other options are incorrect because stacks, unlike queues, ArrayLists, and LinkedLists, follow the Last In First Out (LIFO) principle.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 30,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.3,
    question:
      "Which Java data structure is most suitable for managing tasks in the order they are received?",
    answers: ["Queue", "Stack", "ArrayList", "LinkedList"],
    correct: 0,
    explanations: [
      "The Java data structure most suitable for managing tasks in the order they are received is a queue. Tasks are typically processed in the order they are received, which follows the First In First Out (FIFO) principle.",
      "The other options are incorrect because stacks, ArrayLists, and LinkedLists do not follow the First In First Out (FIFO) principle like queues do.",
      "The other options are incorrect because stacks, ArrayLists, and LinkedLists do not follow the First In First Out (FIFO) principle like queues do.",
      "The other options are incorrect because stacks, ArrayLists, and LinkedLists do not follow the First In First Out (FIFO) principle like queues do.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 30,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.3,
    question:
      "Which data structure is commonly used for implementing back and forward navigation in a web browser?",
    answers: ["Stack", "Queue", "ArrayList", "LinkedList"],
    correct: 0,
    explanations: [
      "The data structure commonly used for implementing back and forward navigation in a web browser is a stack. It allows the user to navigate through previously visited pages in the reverse order they were visited, which follows the Last In First Out (LIFO) principle.",
      "The other options are incorrect because stacks, ArrayLists, and LinkedLists do not follow the Last In First Out (LIFO) principle like queues do.",
      "The other options are incorrect because stacks, ArrayLists, and LinkedLists do not follow the Last In First Out (LIFO) principle like queues do.",
      "The other options are incorrect because stacks, ArrayLists, and LinkedLists do not follow the Last In First Out (LIFO) principle like queues do.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 30,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.3,
    question:
      "Which Java data structure is most suitable for implementing a history feature in a web browser?",
    answers: ["Stack", "Queue", "ArrayList", "LinkedList"],
    correct: 0,
    explanations: [
      "The Java data structure most suitable for implementing a history feature in a web browser is a stack. It allows the user to navigate through previously visited pages in the reverse order they were visited, which follows the Last In First Out (LIFO) principle.",
      "The other options are incorrect because stacks, ArrayLists, and LinkedLists do not follow the Last In First Out (LIFO) principle like queues do.",
      "The other options are incorrect because stacks, ArrayLists, and LinkedLists do not follow the Last In First Out (LIFO) principle like queues do.",
      "The other options are incorrect because stacks, ArrayLists, and LinkedLists do not follow the Last In First Out (LIFO) principle like queues do.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 30,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.3,
    question:
      "What is the primary difference between a stack and a queue in Java?",
    answers: [
      "A stack follows the Last In First Out (LIFO) principle, while a queue follows the First In First Out (FIFO) principle.",
      "A stack follows the First In First Out (FIFO) principle, while a queue follows the Last In First Out (LIFO) principle.",
      "A stack allows elements to be added and removed from both ends, while a queue only allows elements to be added at one end and removed from the other end.",
      "A stack automatically resizes itself when needed, while a queue does not.",
    ],
    correct: 0,
    explanations: [
      "The primary difference between a stack and a queue in Java is that a stack follows the Last In First Out (LIFO) principle, meaning the last element added to the stack will be the first one to be removed, while a queue follows the First In First Out (FIFO) principle.",
      "The other options are incorrect because stacks, unlike queues, do not follow the First In First Out (FIFO) principle.",
      "The other options are incorrect because stacks, unlike queues, do not allow elements to be added and removed from both ends.",
      "The other options are incorrect because stacks, unlike queues, do not automatically resize themselves when needed.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 30,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.3,
    question:
      "Which Java data structure is most appropriate for implementing a waiting line at a supermarket checkout?",
    answers: ["Queue", "Stack", "ArrayList", "LinkedList"],
    correct: 0,
    explanations: [
      "The Java data structure most appropriate for implementing a waiting line at a supermarket checkout is a queue. Customers are typically served in the order they arrived, which follows the First In First Out (FIFO) principle.",
      "The other options are incorrect because stacks, ArrayLists, and LinkedLists do not follow the First In First Out (FIFO) principle like queues do.",
      "The other options are incorrect because stacks, ArrayLists, and LinkedLists do not follow the First In First Out (FIFO) principle like queues do.",
      "The other options are incorrect because stacks, ArrayLists, and LinkedLists do not follow the First In First Out (FIFO) principle like queues do.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 30,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.3,
    question:
      "Which Java data structure is best suited for implementing a stack of books?",
    answers: ["Stack", "Queue", "ArrayList", "LinkedList"],
    correct: 0,
    explanations: [
      "The Java data structure best suited for implementing a stack of books is a stack. A stack follows the Last In First Out (LIFO) principle, making it suitable for scenarios where the last item added should be the first one removed, just like a stack of books.",
      "The other options are incorrect because stacks, unlike queues, ArrayLists, and LinkedLists, follow the Last In First Out (LIFO) principle.",
      "The other options are incorrect because stacks, unlike queues, ArrayLists, and LinkedLists, do not follow the First In First Out (FIFO) principle.",
      "The other options are incorrect because stacks, unlike queues, ArrayLists, and LinkedLists, do not allow elements to be added and removed from both ends.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 30,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.3,
    question:
      "Which data structure is appropriate for implementing a line of customers waiting to purchase movie tickets?",
    answers: ["Queue", "Stack", "ArrayList", "LinkedList"],
    correct: 0,
    explanations: [
      "The appropriate data structure for implementing a line of customers waiting to purchase movie tickets is a queue. A queue follows the First In First Out (FIFO) principle, ensuring that customers are served in the order they arrived, similar to waiting in a line.",
      "The other options are incorrect because queues, unlike stacks, ArrayLists, and LinkedLists, follow the First In First Out (FIFO) principle.",
      "The other options are incorrect because queues, unlike stacks, ArrayLists, and LinkedLists, do not follow the Last In First Out (LIFO) principle.",
      "The other options are incorrect because queues, unlike stacks, ArrayLists, and LinkedLists, do not allow elements to be added and removed from both ends.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 30,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.3,
    question:
      "What is the key characteristic of a queue data structure in Java?",
    answers: [
      "Follows the First In First Out (FIFO) principle.",
      "Follows the Last In First Out (LIFO) principle.",
      "Allows elements to be added and removed from both ends.",
      "Automatically resizes itself when needed.",
    ],
    correct: 0,
    explanations: [
      "The key characteristic of a queue data structure in Java is that it follows the First In First Out (FIFO) principle. This means that the first element added to the queue will be the first one to be removed.",
      "The other options are incorrect because queues, unlike stacks, do not follow the Last In First Out (LIFO) principle.",
      "The other options are incorrect because queues, unlike some other data structures, do not allow elements to be added and removed from both ends.",
      "The other options are incorrect because queues, unlike some other data structures, do not automatically resize themselves when needed.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 30,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.3,
    question:
      "Which Java data structure is most suitable for implementing a waiting list for a restaurant?",
    answers: ["Queue", "Stack", "ArrayList", "LinkedList"],
    correct: 0,
    explanations: [
      "The Java data structure most suitable for implementing a waiting list for a restaurant is a queue. A queue ensures that customers are served in the order they arrived, which follows the First In First Out (FIFO) principle, similar to waiting in line at a restaurant.",
      "The other options are incorrect because queues, unlike stacks, ArrayLists, and LinkedLists, follow the First In First Out (FIFO) principle.",
      "The other options are incorrect because queues, unlike stacks, ArrayLists, and LinkedLists, do not follow the Last In First Out (LIFO) principle.",
      "The other options are incorrect because queues, unlike stacks, ArrayLists, and LinkedLists, do not allow elements to be added and removed from both ends.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 30,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.3,
    question:
      "What is the primary characteristic of a stack data structure in Java?",
    answers: [
      "Follows the Last In First Out (LIFO) principle.",
      "Follows the First In First Out (FIFO) principle.",
      "Allows elements to be added and removed from both ends.",
      "Automatically resizes itself when needed.",
    ],
    correct: 0,
    explanations: [
      "The primary characteristic of a stack data structure in Java is that it follows the Last In First Out (LIFO) principle. This means that the last element added to the stack will be the first one to be removed.",
      "The other options are incorrect because stacks, unlike some other data structures, do not follow the First In First Out (FIFO) principle.",
      "The other options are incorrect because stacks, unlike some other data structures, do not allow elements to be added and removed from both ends.",
      "The other options are incorrect because stacks, unlike some other data structures, do not automatically resize themselves when needed.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 30,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.3,
    question:
      "Which Java data structure is most suitable for implementing a waiting line for a customer service hotline?",
    answers: ["Queue", "Stack", "ArrayList", "LinkedList"],
    correct: 0,
    explanations: [
      "The Java data structure most suitable for implementing a waiting line for a customer service hotline is a queue. A queue ensures that customers are served in the order they called, which follows the First In First Out (FIFO) principle, similar to waiting in line on a hotline.",
      "The other options are incorrect because queues, unlike stacks, ArrayLists, and LinkedLists, follow the First In First Out (FIFO) principle.",
      "The other options are incorrect because queues, unlike stacks, ArrayLists, and LinkedLists, do not follow the Last In First Out (LIFO) principle.",
      "The other options are incorrect because queues, unlike stacks, ArrayLists, and LinkedLists, do not allow elements to be added and removed from both ends.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 30,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.3,
    question:
      "Which Java data structure is most appropriate for implementing an event handling mechanism in a GUI application?",
    answers: ["Queue", "Stack", "ArrayList", "LinkedList"],
    correct: 0,
    explanations: [
      "The Java data structure most appropriate for implementing an event handling mechanism in a GUI application is a queue. Events are typically processed in the order they occur, which follows the First In First Out (FIFO) principle, similar to handling events in a queue.",
      "The other options are incorrect because queues, unlike stacks, ArrayLists, and LinkedLists, follow the First In First Out (FIFO) principle.",
      "The other options are incorrect because queues, unlike stacks, ArrayLists, and LinkedLists, do not follow the Last In First Out (LIFO) principle.",
      "The other options are incorrect because queues, unlike stacks, ArrayLists, and LinkedLists, do not allow elements to be added and removed from both ends.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 30,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.3,
    question: "What is the main characteristic of a queue in Java?",
    answers: [
      "Follows the First In First Out (FIFO) principle.",
      "Follows the Last In First Out (LIFO) principle.",
      "Allows elements to be added and removed from both ends.",
      "Automatically resizes itself when needed.",
    ],
    correct: 0,
    explanations: [
      "The main characteristic of a queue in Java is that it follows the First In First Out (FIFO) principle. This means that the first element added to the queue will be the first one to be removed.",
      "The other options are incorrect because queues, unlike stacks, do not follow the Last In First Out (LIFO) principle.",
      "The other options are incorrect because queues, unlike some other data structures, do not allow elements to be added and removed from both ends.",
      "The other options are incorrect because queues, unlike some other data structures, do not automatically resize themselves when needed.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 30,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.3,
    question:
      "Which Java data structure is most suitable for implementing a waiting line for a taxi service?",
    answers: ["Queue", "Stack", "ArrayList", "LinkedList"],
    correct: 0,
    explanations: [
      "The Java data structure most suitable for implementing a waiting line for a taxi service is a queue. Passengers are typically served in the order they requested a taxi, which follows the First In First Out (FIFO) principle, similar to waiting in line for a taxi.",
      "The other options are incorrect because queues, unlike stacks, ArrayLists, and LinkedLists, follow the First In First Out (FIFO) principle.",
      "The other options are incorrect because queues, unlike stacks, ArrayLists, and LinkedLists, do not follow the Last In First Out (LIFO) principle.",
      "The other options are incorrect because queues, unlike stacks, ArrayLists, and LinkedLists, do not allow elements to be added and removed from both ends.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 30,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.4,
    question:
      "Write a Java code snippet to add an element to the end of an ArrayList named 'list'.",
    code: "list.add(element);",
    answers: [
      "list.add(element);",
      "list.insert(element);",
      "list.push(element);",
      "list.enqueue(element);",
    ],
    correct: 0,
    explanations: [
      "The correct code snippet to add an element to the end of an ArrayList in Java is 'list.add(element);'. This method appends the specified element to the end of the list.",
      "The other options are incorrect because 'insert' is not a method in ArrayLists.",
      "The other options are incorrect because 'push' and 'enqueue' are not methods in ArrayLists.",
      "The other options are incorrect because 'enqueue' is not a method in ArrayLists.",
    ],
    bloomTaxonomy: "Applying",
    timeTakenSeconds: 60,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.4,
    question:
      "Write a Java code snippet to remove the first element from a LinkedList named 'list'.",
    code: "list.removeFirst();",
    answers: [
      "list.removeFirst();",
      "list.deleteFirst();",
      "list.pop();",
      "list.dequeue();",
    ],
    correct: 0,
    explanations: [
      "The correct code snippet to remove the first element from a LinkedList in Java is 'list.removeFirst();'. This method removes and returns the first element of the list.",
      "The other options are incorrect because LinkedLists do not have a 'deleteFirst()' method.",
      "The other options are incorrect because LinkedLists do not have a 'pop()' method.",
      "The other options are incorrect because LinkedLists do not have a 'dequeue()' method.",
    ],
    bloomTaxonomy: "Applying",
    timeTakenSeconds: 60,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.4,
    question:
      "Write a Java code snippet to push an element onto a stack named 'stack'.",
    code: "stack.push(element);",
    answers: [
      "stack.push(element);",
      "stack.add(element);",
      "stack.insert(element);",
      "stack.enqueue(element);",
    ],
    correct: 0,
    explanations: [
      "The correct code snippet to push an element onto a stack in Java is 'stack.push(element);'. This method pushes an element onto the top of the stack.",
      "The other options are incorrect because stacks do not have an 'add()' method.",
      "The other options are incorrect because stacks do not have an 'insert()' method.",
      "The other options are incorrect because stacks do not have an 'enqueue()' method.",
    ],
    bloomTaxonomy: "Applying",
    timeTakenSeconds: 60,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.4,
    question:
      "Write a Java code snippet to enqueue an element into a queue named 'queue'.",
    code: "queue.add(element);",
    answers: [
      "queue.add(element);",
      "queue.insert(element);",
      "queue.push(element);",
      "queue.enqueue(element);",
    ],
    correct: 0,
    explanations: [
      "The correct code snippet to enqueue an element into a queue in Java is 'queue.add(element);'. This method adds the specified element to the end of the queue.",
      "The other options are incorrect because queues do not have an 'insert()' method.",
      "The other options are incorrect because queues do not have a 'push()' method.",
      "The other options are incorrect because queues do not have an 'enqueue()' method.",
    ],
    bloomTaxonomy: "Applying",
    timeTakenSeconds: 60,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.4,
    question:
      "Write a Java code snippet to remove an element from the top of a stack named 'stack'.",
    code: "stack.pop();",
    answers: [
      "stack.pop();",
      "stack.remove();",
      "stack.delete();",
      "stack.dequeue();",
    ],
    correct: 0,
    explanations: [
      "The correct code snippet to remove an element from the top of a stack in Java is 'stack.pop();'. This method removes and returns the top element of the stack.",
      "The other options are incorrect because stacks do not have a 'remove()' method.",
      "The other options are incorrect because stacks do not have a 'delete()' method.",
      "The other options are incorrect because stacks do not have a 'dequeue()' method.",
    ],
    bloomTaxonomy: "Applying",
    timeTakenSeconds: 60,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.4,
    question:
      "Write a Java code snippet to dequeue an element from a queue named 'queue'.",
    code: "queue.remove();",
    answers: [
      "queue.remove();",
      "queue.delete();",
      "queue.pop();",
      "queue.dequeue();",
    ],
    correct: 0,
    explanations: [
      "The correct code snippet to dequeue an element from a queue in Java is 'queue.remove();'. This method removes and returns the element at the front of the queue.",
      "The other options are incorrect because queues do not have a 'delete()' method.",
      "The other options are incorrect because queues do not have a 'pop()' method.",
      "The other options are incorrect because queues do not have a 'dequeue()' method.",
    ],
    bloomTaxonomy: "Applying",
    timeTakenSeconds: 60,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.4,
    question:
      "Write a Java code snippet to insert an element at the front of a LinkedList named 'list'.",
    code: "list.addFirst(element);",
    answers: [
      "list.addFirst(element);",
      "list.insertFirst(element);",
      "list.push(element);",
      "list.enqueue(element);",
    ],
    correct: 0,
    explanations: [
      "The correct code snippet to insert an element at the front of a LinkedList in Java is 'list.addFirst(element);'. This method inserts the specified element at the beginning of the list.",
      "The other options are incorrect because LinkedLists do not have an 'insertFirst()' method.",
      "The other options are incorrect because LinkedLists do not have a 'push()' method.",
      "The other options are incorrect because LinkedLists do not have an 'enqueue()' method.",
    ],
    bloomTaxonomy: "Applying",
    timeTakenSeconds: 60,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.4,
    question:
      "Write a Java code snippet to remove the last element from an ArrayList named 'list'.",
    code: "list.remove(list.size() - 1);",
    answers: [
      "list.remove(list.size() - 1);",
      "list.removeLast();",
      "list.pop();",
      "list.dequeue();",
    ],
    correct: 0,
    explanations: [
      "The correct code snippet to remove the last element from an ArrayList in Java is 'list.remove(list.size() - 1);'. This method removes the element at the specified index, which in this case is the last element.",
      "The other options are incorrect because ArrayLists do not have a 'removeLast()' method.",
      "The other options are incorrect because ArrayLists do not have a 'pop()' method.",
      "The other options are incorrect because ArrayLists do not have a 'dequeue()' method.",
    ],
    bloomTaxonomy: "Applying",
    timeTakenSeconds: 60,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.4,
    question:
      "Write a Java code snippet to remove the first occurrence of a specified element from an ArrayList named 'list'.",
    code: "list.remove(element);",
    answers: [
      "list.remove(element);",
      "list.removeFirstOccurrence(element);",
      "list.delete(element);",
      "list.dequeue(element);",
    ],
    correct: 0,
    explanations: [
      "The correct code snippet to remove the first occurrence of a specified element from an ArrayList in Java is 'list.remove(element);'. This method removes the first occurrence of the specified element from the list, if it is present.",
      "The other options are incorrect because ArrayLists do not have a 'removeFirstOccurrence()' method.",
      "The other options are incorrect because ArrayLists do not have a 'delete()' method.",
      "The other options are incorrect because ArrayLists do not have a 'dequeue()' method.",
    ],
    bloomTaxonomy: "Applying",
    timeTakenSeconds: 60,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.4,
    question:
      "Write a Java code snippet to check if a stack named 'stack' is empty.",
    code: "boolean isEmpty = stack.isEmpty();",
    answers: [
      "boolean isEmpty = stack.isEmpty();",
      "boolean isEmpty = stack.size() == 0;",
      "boolean isEmpty = stack.length() == 0;",
      "boolean isEmpty = stack.top() == null;",
    ],
    correct: 0,
    explanations: [
      "The correct code snippet to check if a stack is empty in Java is 'boolean isEmpty = stack.isEmpty();'. This method returns true if the stack is empty, false otherwise.",
      "The other options are incorrect because stacks do not have a 'length()' method.",
      "The other options are incorrect because stacks do not have a 'length()' method.",
      "The other options are incorrect because stacks do not have a 'top()' method.",
    ],
    bloomTaxonomy: "Applying",
    timeTakenSeconds: 60,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.4,
    question:
      "Write a Java code snippet to reverse the order of elements in an ArrayList named 'list'.",
    code: "Collections.reverse(list);",
    answers: [
      "Collections.reverse(list);",
      "list.reverse();",
      "list.reverseOrder();",
      "list.reverseList();",
    ],
    correct: 0,
    explanations: [
      "The correct code snippet to reverse the order of elements in an ArrayList in Java is 'Collections.reverse(list);'. This method reverses the order of elements in the specified list.",
      "The other options are incorrect because ArrayLists do not have a 'reverse()' method.",
      "The other options are incorrect because ArrayLists do not have a 'reverseOrder()' method.",
      "The other options are incorrect because ArrayLists do not have a 'reverseList()' method.",
    ],
    bloomTaxonomy: "Applying",
    timeTakenSeconds: 60,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.4,
    question:
      "Write a Java code snippet to check if an ArrayList named 'list' contains a specified element.",
    code: "boolean containsElement = list.contains(element);",
    answers: [
      "boolean containsElement = list.contains(element);",
      "boolean containsElement = list.hasElement(element);",
      "boolean containsElement = list.includes(element);",
      "boolean containsElement = list.find(element);",
    ],
    correct: 0,
    explanations: [
      "The correct code snippet to check if an ArrayList contains a specified element in Java is 'boolean containsElement = list.contains(element);'. This method returns true if the list contains the specified element, false otherwise.",
      "The other options are incorrect because ArrayLists do not have a 'hasElement()' method.",
      "The other options are incorrect because ArrayLists do not have an 'includes()' method.",
      "The other options are incorrect because ArrayLists do not have a 'find()' method.",
    ],
    bloomTaxonomy: "Applying",
    timeTakenSeconds: 60,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.4,
    question:
      "Write a Java code snippet to retrieve the first element from a LinkedList named 'list' without removing it.",
    code: "Object firstElement = list.getFirst();",
    answers: [
      "Object firstElement = list.getFirst();",
      "Object firstElement = list.peek();",
      "Object firstElement = list.top();",
      "Object firstElement = list.front();",
    ],
    correct: 0,
    explanations: [
      "The correct code snippet to retrieve the first element from a LinkedList in Java without removing it is 'Object firstElement = list.getFirst();'. This method returns the first element of the list without removing it.",
      "The other options are incorrect because LinkedLists do not have a 'peek()' method.",
      "The other options are incorrect because LinkedLists do not have a 'top()' method.",
      "The other options are incorrect because LinkedLists do not have a 'front()' method.",
    ],
    bloomTaxonomy: "Applying",
    timeTakenSeconds: 60,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.4,
    question:
      "Write a Java code snippet to retrieve and remove the last element from a LinkedList named 'list'.",
    code: "Object lastElement = list.pollLast();",
    answers: [
      "Object lastElement = list.pollLast();",
      "Object lastElement = list.removeLast();",
      "Object lastElement = list.pop();",
      "Object lastElement = list.dequeue();",
    ],
    correct: 0,
    explanations: [
      "The correct code snippet to retrieve and remove the last element from a LinkedList in Java is 'Object lastElement = list.pollLast();'. This method retrieves and removes the last element of the list, or returns null if the list is empty.",
      "The other options are incorrect because LinkedLists do not have a 'removeLast()' method.",
      "The other options are incorrect because LinkedLists do not have a 'pop()' method.",
      "The other options are incorrect because LinkedLists do not have a 'dequeue()' method.",
    ],
    bloomTaxonomy: "Applying",
    timeTakenSeconds: 60,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.4,
    question:
      "Write a Java code snippet to get the index of the first occurrence of a specified element in an ArrayList named 'list'.",
    code: "int index = list.indexOf(element);",
    answers: [
      "int index = list.indexOf(element);",
      "int index = list.search(element);",
      "int index = list.findIndex(element);",
      "int index = list.getIndex(element);",
    ],
    correct: 0,
    explanations: [
      "The correct code snippet to get the index of the first occurrence of a specified element in an ArrayList in Java is 'int index = list.indexOf(element);'. This method returns the index of the first occurrence of the specified element in the list, or -1 if the element is not found.",
      "The other options are incorrect because ArrayLists do not have a 'search()' method.",
      "The other options are incorrect because ArrayLists do not have a 'findIndex()' method.",
      "The other options are incorrect because ArrayLists do not have a 'getIndex()' method.",
    ],
    bloomTaxonomy: "Applying",
    timeTakenSeconds: 60,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.4,
    question:
      "Write a Java code snippet to remove all elements from an ArrayList named 'list'.",
    code: "list.clear();",
    answers: [
      "list.clear();",
      "list.removeAll();",
      "list.deleteAll();",
      "list.remove();",
    ],
    correct: 0,
    explanations: [
      "The correct code snippet to remove all elements from an ArrayList in Java is 'list.clear();'. This method removes all of the elements from the list, leaving it empty.",
      "The other options are incorrect because ArrayLists do not have a 'removeAll()' method.",
      "The other options are incorrect because ArrayLists do not have a 'deleteAll()' method.",
      "The other options are incorrect because ArrayLists do not have a 'remove()' method.",
    ],
    bloomTaxonomy: "Applying",
    timeTakenSeconds: 60,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.4,
    question:
      "Write a Java code snippet to check if a LinkedList named 'list' is empty.",
    code: "boolean isEmpty = list.isEmpty();",
    answers: [
      "boolean isEmpty = list.isEmpty();",
      "boolean isEmpty = list.size() == 0;",
      "boolean isEmpty = list.length() == 0;",
      "boolean isEmpty = list.first() == null;",
    ],
    correct: 0,
    explanations: [
      "The correct code snippet to check if a LinkedList is empty in Java is 'boolean isEmpty = list.isEmpty();'. This method returns true if the list is empty, false otherwise.",
      "The other options are incorrect because LinkedLists do not have a 'length()' method.",
      "The other options are incorrect because LinkedLists do not have a 'length()' method.",
      "The other options are incorrect because LinkedLists do not have a 'first()' method.",
    ],
    bloomTaxonomy: "Applying",
    timeTakenSeconds: 60,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.4,
    question:
      "Write a Java code snippet to check if a LinkedList named 'list' contains a specified element.",
    code: "boolean containsElement = list.contains(element);",
    answers: [
      "boolean containsElement = list.contains(element);",
      "boolean containsElement = list.hasElement(element);",
      "boolean containsElement = list.includes(element);",
      "boolean containsElement = list.find(element);",
    ],
    correct: 0,
    explanations: [
      "The correct code snippet to check if a LinkedList contains a specified element in Java is 'boolean containsElement = list.contains(element);'. This method returns true if the list contains the specified element, false otherwise.",
      "The other options are incorrect because LinkedLists do not have a 'hasElement()' method.",
      "The other options are incorrect because LinkedLists do not have an 'includes()' method.",
      "The other options are incorrect because LinkedLists do not have a 'find()' method.",
    ],
    bloomTaxonomy: "Applying",
    timeTakenSeconds: 60,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.4,
    question:
      "Write a Java code snippet to remove all occurrences of a specified element from an ArrayList named 'list'.",
    code: "list.removeAll(Collections.singleton(element));",
    answers: [
      "list.removeAll(Collections.singleton(element));",
      "list.remove(element);",
      "list.delete(element);",
      "list.dequeue(element);",
    ],
    correct: 0,
    explanations: [
      "The correct code snippet to remove all occurrences of a specified element from an ArrayList in Java is 'list.removeAll(Collections.singleton(element));'. This method removes all occurrences of the specified element from the list.",
      "The other options are incorrect because ArrayLists do not have a 'remove()' method.",
      "The other options are incorrect because ArrayLists do not have a 'delete()' method.",
      "The other options are incorrect because ArrayLists do not have a 'dequeue()' method.",
    ],
    bloomTaxonomy: "Applying",
    timeTakenSeconds: 60,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.4,
    question:
      "Write a Java code snippet to retrieve and remove the first element from a LinkedList named 'list'.",
    code: "Object firstElement = list.poll();",
    answers: [
      "Object firstElement = list.poll();",
      "Object firstElement = list.removeFirst();",
      "Object firstElement = list.pop();",
      "Object firstElement = list.dequeue();",
    ],
    correct: 0,
    explanations: [
      "The correct code snippet to retrieve and remove the first element from a LinkedList in Java is 'Object firstElement = list.poll();'. This method retrieves and removes the first element of the list, or returns null if the list is empty.",
      "The other options are incorrect because LinkedLists do not have a 'removeFirst()' method.",
      "The other options are incorrect because LinkedLists do not have a 'pop()' method.",
      "The other options are incorrect because LinkedLists do not have a 'dequeue()' method.",
    ],
    bloomTaxonomy: "Applying",
    timeTakenSeconds: 60,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.5,
    question:
      "Consider the following Java code snippet. What will be the output of the code?\n\n```java\nList<Integer> list = new ArrayList<>();\nlist.add(1);\nlist.add(2);\nlist.add(3);\nlist.add(4);\nlist.remove(2);\nSystem.out.println(list);\n```\n",
    code: "List<Integer> list = new ArrayList<>();\nlist.add(1);\nlist.add(2);\nlist.add(3);\nlist.add(4);\nlist.remove(2);\nSystem.out.println(list);",
    answers: ["[1, 2, 4]", "[1, 3, 4]", "[1, 2, 3]", "[1, 4]"],
    correct: 0,
    explanations: [
      "The output of the code will be [1, 2, 4]. The remove() method in ArrayList removes the element at the specified index, which in this case is 2 (the third element), resulting in the list [1, 2, 4].",
      "The other options are incorrect because they do not reflect the removal of the element at index 2 as performed by the remove() method.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 90,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.5,
    question:
      'Consider the following Java code snippet. What will be the output of the code?\n\n```java\nQueue<String> queue = new LinkedList<>();\nqueue.add("A");\nqueue.add("B");\nqueue.offer("C");\nqueue.remove();\nSystem.out.println(queue);\n```\n',
    code: 'Queue<String> queue = new LinkedList<>();\nqueue.add("A");\nqueue.add("B");\nqueue.offer("C");\nqueue.remove();\nSystem.out.println(queue);',
    answers: ["[B, C]", "[A, B, C]", "[B, A, C]", "[A, C]"],
    correct: 0,
    explanations: [
      "The output of the code will be [B, C]. The remove() method in Queue removes and returns the head of the queue, which is 'A' in this case, resulting in the queue [B, C].",
      "The other options are incorrect because they do not reflect the removal of the element at the head of the queue as performed by the remove() method.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 90,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.5,
    question:
      "Consider the following Java code snippet. What will be the output of the code?\n\n```java\nStack<Integer> stack = new Stack<>();\nstack.push(1);\nstack.push(2);\nstack.push(3);\nstack.pop();\nSystem.out.println(stack);\n```\n",
    code: "Stack<Integer> stack = new Stack<>();\nstack.push(1);\nstack.push(2);\nstack.push(3);\nstack.pop();\nSystem.out.println(stack);",
    answers: ["[1, 2]", "[1, 2, 3]", "[2, 3]", "[1, 3]"],
    correct: 0,
    explanations: [
      "The output of the code will be [1, 2]. The pop() method in Stack removes and returns the top element of the stack, which is '3' in this case, resulting in the stack [1, 2].",
      "The other options are incorrect because they do not reflect the removal of the top element of the stack as performed by the pop() method.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 90,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.5,
    question:
      'Consider the following Java code snippet. What will be the output of the code?\n\n```java\nList<String> list = new LinkedList<>();\nlist.add("A");\nlist.add("B");\nlist.add("C");\nlist.set(1, "D");\nSystem.out.println(list);\n```\n',
    code: 'List<String> list = new LinkedList<>();\nlist.add("A");\nlist.add("B");\nlist.add("C");\nlist.set(1, "D");\nSystem.out.println(list);',
    answers: ["[A, D, C]", "[A, D, B, C]", "[D, B, C]", "[A, B, D, C]"],
    correct: 0,
    explanations: [
      "The output of the code will be [A, D, C]. The set() method in LinkedList replaces the element at the specified index with the specified element, resulting in the list [A, D, C].",
      "The other options are incorrect because they do not reflect the replacement of the element at index 1 as performed by the set() method.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 90,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.5,
    question:
      "Consider the following Java code snippet. What will be the output of the code?\n\n```java\nList<Integer> list = new ArrayList<>();\nlist.add(1);\nlist.add(2);\nlist.add(3);\nlist.add(4);\nSystem.out.println(list.get(2));\n```\n",
    code: "List<Integer> list = new ArrayList<>();\nlist.add(1);\nlist.add(2);\nlist.add(3);\nlist.add(4);\nSystem.out.println(list.get(2));",
    answers: ["3", "2", "4", "1"],
    correct: 0,
    explanations: [
      "The output of the code will be 3. The get() method in ArrayList returns the element at the specified index, which in this case is 2, resulting in the value 3.",
      "The other options are incorrect because they do not reflect the retrieval of the element at index 2 as performed by the get() method.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 90,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.5,
    question:
      'Consider the following Java code snippet. What will be the output of the code?\n\n```java\nStack<String> stack = new Stack<>();\nstack.push("A");\nstack.push("B");\nstack.push("C");\nSystem.out.println(stack.peek());\n```\n',
    code: 'Stack<String> stack = new Stack<>();\nstack.push("A");\nstack.push("B");\nstack.push("C");\nSystem.out.println(stack.peek());',
    answers: ["C", "B", "A", "null"],
    correct: 0,
    explanations: [
      "The output of the code will be C. The peek() method in Stack returns the top element of the stack without removing it, which in this case is 'C'.",
      "The other options are incorrect because they do not reflect the retrieval of the top element of the stack as performed by the peek() method.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 90,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.5,
    question:
      "Consider the following Java code snippet. What will be the output of the code?\n\n```java\nQueue<Integer> queue = new LinkedList<>();\nqueue.add(1);\nqueue.add(2);\nqueue.add(3);\nSystem.out.println(queue.poll());\n```\n",
    code: "Queue<Integer> queue = new LinkedList<>();\nqueue.add(1);\nqueue.add(2);\nqueue.add(3);\nSystem.out.println(queue.poll());",
    answers: ["1", "2", "3", "null"],
    correct: 0,
    explanations: [
      "The output of the code will be 1. The poll() method in Queue removes and returns the head of the queue, which in this case is '1'.",
      "The other options are incorrect because they do not reflect the removal of the head of the queue as performed by the poll() method.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 90,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.5,
    question:
      'Consider the following Java code snippet. What will be the output of the code?\n\n```java\nList<String> list = new ArrayList<>();\nlist.add("A");\nlist.add("B");\nlist.add("C");\nlist.remove(1);\nSystem.out.println(list);\n```\n',
    code: 'List<String> list = new ArrayList<>();\nlist.add("A");\nlist.add("B");\nlist.add("C");\nlist.remove(1);\nSystem.out.println(list);',
    answers: ["[A, C]", "[A, B, C]", "[A, C, B]", "[C, B, A]"],
    correct: 0,
    explanations: [
      "The output of the code will be [A, C]. The remove() method in ArrayList removes the element at the specified index, which in this case is 1 (the second element), resulting in the list [A, C].",
      "The other options are incorrect because they do not reflect the removal of the element at index 1 as performed by the remove() method.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 90,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.5,
    question:
      "Consider the following Java code snippet. What will be the output of the code?\n\n```java\nStack<Integer> stack = new Stack<>();\nstack.push(1);\nstack.push(2);\nstack.push(3);\nSystem.out.println(stack.pop());\n```\n",
    code: "Stack<Integer> stack = new Stack<>();\nstack.push(1);\nstack.push(2);\nstack.push(3);\nSystem.out.println(stack.pop());",
    answers: ["3", "2", "1", "null"],
    correct: 0,
    explanations: [
      "The output of the code will be 3. The pop() method in Stack removes and returns the top element of the stack, which in this case is '3'.",
      "The other options are incorrect because they do not reflect the removal of the top element of the stack as performed by the pop() method.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 90,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.5,
    question:
      'Consider the following Java code snippet. What will be the output of the code?\n\n```java\nQueue<String> queue = new LinkedList<>();\nqueue.add("A");\nqueue.add("B");\nqueue.add("C");\nSystem.out.println(queue.peek());\n```\n',
    code: 'Queue<String> queue = new LinkedList<>();\nqueue.add("A");\nqueue.add("B");\nqueue.add("C");\nSystem.out.println(queue.peek());',
    answers: ["A", "B", "C", "null"],
    correct: 0,
    explanations: [
      "The output of the code will be A. The peek() method in Queue returns the head of the queue without removing it, which in this case is 'A'.",
      "The other options are incorrect because they do not reflect the retrieval of the head of the queue as performed by the peek() method.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 90,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.5,
    question:
      "Consider the following Java code snippet. What will be the output of the code?\n\n```java\nList<Integer> list = new ArrayList<>();\nlist.add(1);\nlist.add(2);\nlist.add(3);\nlist.add(4);\nlist.remove(Integer.valueOf(2));\nSystem.out.println(list);\n```\n",
    code: "List<Integer> list = new ArrayList<>();\nlist.add(1);\nlist.add(2);\nlist.add(3);\nlist.add(4);\nlist.remove(Integer.valueOf(2));\nSystem.out.println(list);",
    answers: ["[1, 3, 4]", "[1, 2, 4]", "[1, 3]", "[1, 2, 3]"],
    correct: 0,
    explanations: [
      "The output of the code will be [1, 3, 4]. The remove() method in ArrayList removes the first occurrence of the specified element from the list, which in this case is '2', resulting in the list [1, 3, 4].",
      "The other options are incorrect because they do not reflect the removal of the specified element as performed by the remove() method.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 90,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.5,
    question:
      'Consider the following Java code snippet. What will be the output of the code?\n\n```java\nQueue<String> queue = new LinkedList<>();\nqueue.add("A");\nqueue.add("B");\nqueue.offer("C");\nqueue.poll();\nSystem.out.println(queue);\n```\n',
    code: 'Queue<String> queue = new LinkedList<>();\nqueue.add("A");\nqueue.add("B");\nqueue.offer("C");\nqueue.poll();\nSystem.out.println(queue);',
    answers: ["[B, C]", "[A, B, C]", "[B, A, C]", "[A, C]"],
    correct: 0,
    explanations: [
      "The output of the code will be [B, C]. The poll() method in Queue removes and returns the head of the queue, which is 'A' in this case, resulting in the queue [B, C].",
      "Option [A, B, C] is incorrect because it includes 'A' which has been removed by the poll() method.",
      "Option [B, A, C] is incorrect because it has 'A' in the first position, but 'A' has been removed by the poll() method.",
      "Option [A, C] is incorrect because it does not include 'B', which is still in the queue after the poll() method.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 90,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.5,
    question:
      "Consider the following Java code snippet. What will be the output of the code?\n\n```java\nStack<Integer> stack = new Stack<>();\nstack.push(1);\nstack.push(2);\nstack.push(3);\nstack.peek();\nSystem.out.println(stack);\n```\n",
    code: "Stack<Integer> stack = new Stack<>();\nstack.push(1);\nstack.push(2);\nstack.push(3);\nstack.peek();\nSystem.out.println(stack);",
    answers: ["[1, 2, 3]", "[3, 2, 1]", "[1, 2]", "[1, 2, 3, null]"],
    correct: 0,
    explanations: [
      "The output of the code will be [1, 2, 3]. The peek() method in Stack returns the top element of the stack without removing it, so it doesn't affect the stack, resulting in [1, 2, 3].",
      "Option [3, 2, 1] is incorrect because it reverses the order of elements.",
      "Option [1, 2] is incorrect because it does not include '3', which is part of the stack after the peek() operation.",
      "Option [1, 2, 3, null] is incorrect because it includes 'null', which is not part of the stack.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 90,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.5,
    question:
      'Consider the following Java code snippet. What will be the output of the code?\n\n```java\nList<String> list = new ArrayList<>();\nlist.add("A");\nlist.add("B");\nlist.add("C");\nlist.set(1, "D");\nlist.add("E");\nSystem.out.println(list);\n```\n',
    code: 'List<String> list = new ArrayList<>();\nlist.add("A");\nlist.add("B");\nlist.add("C");\nlist.set(1, "D");\nlist.add("E");\nSystem.out.println(list);',
    answers: [
      "[A, D, C, E]",
      "[A, D, B, C, E]",
      "[A, B, D, C, E]",
      "[A, C, D, E]",
    ],
    correct: 0,
    explanations: [
      "The output of the code will be [A, D, C, E]. The set() method in ArrayList replaces the element at the specified index with the specified element, and the add() method adds the element at the end of the list, resulting in [A, D, C, E].",
      "Option [A, D, B, C, E] is incorrect because it includes 'B', which has been replaced by 'D' using the set() method.",
      "Option [A, B, D, C, E] is incorrect because it does not maintain the correct order of elements after the set() and add() operations.",
      "Option [A, C, D, E] is incorrect because it does not include 'B', which is part of the list after the set() and add() operations.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 90,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.5,
    question:
      'Consider the following Java code snippet. What will be the output of the code?\n\n```java\nStack<String> stack = new Stack<>();\nstack.push("A");\nstack.push("B");\nstack.push("C");\nstack.push("D");\nstack.remove("B");\nSystem.out.println(stack);\n```\n',
    code: 'Stack<String> stack = new Stack<>();\nstack.push("A");\nstack.push("B");\nstack.push("C");\nstack.push("D");\nstack.remove("B");\nSystem.out.println(stack);',
    answers: ["[A, D, C]", "[A, B, D, C]", "[D, C, B, A]", "[D, C, A]"],
    correct: 0,
    explanations: [
      "The output of the code will be [A, D, C]. The remove() method in Stack removes the specified element from the stack, which in this case is 'B', resulting in [A, D, C].",
      "Option [A, B, D, C] is incorrect because it maintains the position of 'B', which has been removed.",
      "Option [D, C, B, A] is incorrect because it reverses the order of elements.",
      "Option [D, C, A] is incorrect because it does not include 'B', which has been removed from the stack.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 90,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.5,
    question:
      "Consider the following Java code snippet. What will be the output of the code?\n\n```java\nQueue<Integer> queue = new LinkedList<>();\nqueue.add(1);\nqueue.add(2);\nqueue.add(3);\nqueue.remove();\nSystem.out.println(queue);\n```\n",
    code: "Queue<Integer> queue = new LinkedList<>();\nqueue.add(1);\nqueue.add(2);\nqueue.add(3);\nqueue.remove();\nSystem.out.println(queue);",
    answers: ["[2, 3]", "[1, 2, 3]", "[1, 2]", "[1, 3]"],
    correct: 0,
    explanations: [
      "The output of the code will be [2, 3]. The remove() method in Queue removes and returns the head of the queue, which is '1' in this case, resulting in the queue [2, 3].",
      "Option [1, 2, 3] is incorrect because it includes '1', which has been removed by the remove() method.",
      "Option [1, 2] is incorrect because it does not include '3', which is part of the queue after the remove() operation.",
      "Option [1, 3] is incorrect because it does not include '2', which is part of the queue after the remove() operation.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 90,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.5,
    question:
      'Consider the following Java code snippet. What will be the output of the code?\n\n```java\nList<String> list = new ArrayList<>();\nlist.add("A");\nlist.add("B");\nlist.add("C");\nlist.add("D");\nlist.remove(2);\nSystem.out.println(list);\n```\n',
    code: 'List<String> list = new ArrayList<>();\nlist.add("A");\nlist.add("B");\nlist.add("C");\nlist.add("D");\nlist.remove(2);\nSystem.out.println(list);',
    answers: ["[A, B, D]", "[A, B, C, D]", "[A, D]", "[B, C, D]"],
    correct: 0,
    explanations: [
      "The output of the code will be [A, B, D]. The remove() method in ArrayList removes the element at the specified index, which in this case is 'C' at index 2, resulting in the list [A, B, D].",
      "Option [A, B, C, D] is incorrect because it includes 'C', which has been removed at index 2.",
      "Option [A, D] is incorrect because it does not include 'B', which is part of the list after the remove() operation.",
      "Option [B, C, D] is incorrect because it does not maintain the correct order of elements after the remove() operation.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 90,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.5,
    question:
      "Consider the following Java code snippet. What will be the output of the code?\n\n```java\nQueue<Integer> queue = new LinkedList<>();\nqueue.add(1);\nqueue.add(2);\nqueue.add(3);\nqueue.peek();\nSystem.out.println(queue);\n```\n",
    code: "Queue<Integer> queue = new LinkedList<>();\nqueue.add(1);\nqueue.add(2);\nqueue.add(3);\nqueue.peek();\nSystem.out.println(queue);",
    answers: ["[1, 2, 3]", "[3, 2, 1]", "[1, 2]", "[1, 2, 3, null]"],
    correct: 0,
    explanations: [
      "The output of the code will be [1, 2, 3]. The peek() method in Queue returns the head of the queue without removing it, so it doesn't affect the queue, resulting in [1, 2, 3].",
      "Option [3, 2, 1] is incorrect because it reverses the order of elements.",
      "Option [1, 2] is incorrect because it does not include '3', which is part of the queue after the peek() operation.",
      "Option [1, 2, 3, null] is incorrect because it includes 'null', which is not part of the queue.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 90,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.5,
    question:
      'Consider the following Java code snippet. What will be the output of the code?\n\n```java\nStack<String> stack = new Stack<>();\nstack.push("A");\nstack.push("B");\nstack.push("C");\nstack.remove("A");\nSystem.out.println(stack);\n```\n',
    code: 'Stack<String> stack = new Stack<>();\nstack.push("A");\nstack.push("B");\nstack.push("C");\nstack.remove("A");\nSystem.out.println(stack);',
    answers: ["[C, B]", "[A, B, C]", "[B, C, A]", "[A, C, B]"],
    correct: 0,
    explanations: [
      "The output of the code will be [C, B]. The remove() method in Stack removes the specified element from the stack, which in this case is 'A', resulting in [C, B].",
      "Option [A, B, C] is incorrect because it maintains the position of 'A', which has been removed.",
      "Option [B, C, A] is incorrect because it changes the order of elements.",
      "Option [A, C, B] is incorrect because it includes 'A', which has been removed from the stack.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 90,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.5,
    question:
      "Consider the following Java code snippet. What will be the output of the code?\n\n```java\nList<Integer> list = new ArrayList<>();\nlist.add(1);\nlist.add(2);\nlist.add(3);\nlist.add(4);\nlist.remove(3);\nSystem.out.println(list);\n```\n",
    code: "List<Integer> list = new ArrayList<>();\nlist.add(1);\nlist.add(2);\nlist.add(3);\nlist.add(4);\nlist.remove(3);\nSystem.out.println(list);",
    answers: ["[1, 2, 3]", "[1, 2, 4]", "[2, 3, 4]", "[1, 2, 3, 4]"],
    correct: 0,
    explanations: [
      "The output of the code will be [1, 2, 3]. The remove() method in ArrayList removes the element at the specified index, which in this case is '4' at index 3, resulting in the list [1, 2, 3].",
      "Option [1, 2, 4] is incorrect because it includes '4', which has been removed at index 3.",
      "Option [2, 3, 4] is incorrect because it does not include '1', which is part of the list after the remove() operation.",
      "Option [1, 2, 3, 4] is incorrect because it includes '4', which has been removed at index 3.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 90,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.3,
    question:
      'Consider the following Java code snippet. What will be the output of the code?\n\n```java\nList<String> list = new ArrayList<>();\nlist.add("apple");\nlist.add("banana");\nlist.add("orange");\nlist.remove("banana");\nSystem.out.println(list);\n```\n',
    code: 'List<String> list = new ArrayList<>();\nlist.add("apple");\nlist.add("banana");\nlist.add("orange");\nlist.remove("banana");\nSystem.out.println(list);',
    answers: [
      "[apple, orange]",
      "[apple, banana, orange]",
      "[orange]",
      "[banana, orange]",
    ],
    correct: 0,
    explanations: [
      "The output of the code will be [apple, orange]. The remove() method in ArrayList removes the specified element from the list, which in this case is 'banana', resulting in the list [apple, orange].",
      "Option [apple, banana, orange] is incorrect because it includes 'banana', which has been removed from the list.",
      "Option [orange] is incorrect because it does not include 'apple', which is still in the list.",
      "Option [banana, orange] is incorrect because it includes 'banana', which has been removed from the list.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 60,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.3,
    question:
      "Consider the following Java code snippet. What will be the output of the code?\n\n```java\nQueue<Integer> queue = new LinkedList<>();\nqueue.add(5);\nqueue.add(10);\nqueue.remove();\nqueue.add(15);\nSystem.out.println(queue);\n```\n",
    code: "Queue<Integer> queue = new LinkedList<>();\nqueue.add(5);\nqueue.add(10);\nqueue.remove();\nqueue.add(15);\nSystem.out.println(queue);",
    answers: ["[10, 15]", "[5, 15]", "[5, 10, 15]", "[15]"],
    correct: 0,
    explanations: [
      "The output of the code will be [10, 15]. The remove() method in Queue removes and returns the head of the queue, which is '5' in this case, then the add() method adds '15' to the end of the queue, resulting in the queue [10, 15].",
      "Option [5, 15] is incorrect because it includes '5', which has been removed from the queue.",
      "Option [5, 10, 15] is incorrect because it maintains the order of elements including '5', which has been removed from the queue.",
      "Option [15] is incorrect because it does not include '10', which is part of the queue after the remove() operation.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 60,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.3,
    question:
      'Consider the following Java code snippet. What will be the output of the code?\n\n```java\nStack<String> stack = new Stack<>();\nstack.push("red");\nstack.push("green");\nstack.pop();\nstack.push("blue");\nSystem.out.println(stack);\n```\n',
    code: 'Stack<String> stack = new Stack<>();\nstack.push("red");\nstack.push("green");\nstack.pop();\nstack.push("blue");\nSystem.out.println(stack);',
    answers: ["[red, blue]", "[red, green, blue]", "[blue]", "[green, blue]"],
    correct: 0,
    explanations: [
      "The output of the code will be [red, blue]. The pop() method in Stack removes and returns the top element of the stack, which is 'green' in this case, then the push() method adds 'blue' to the top of the stack, resulting in the stack [red, blue].",
      "Option [red, green, blue] is incorrect because it includes 'green', which has been removed from the stack.",
      "Option [blue] is incorrect because it does not include 'red', which is part of the stack.",
      "Option [green, blue] is incorrect because it includes 'green', which has been removed from the stack.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 60,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.3,
    question:
      "Consider the following Java code snippet. What will be the output of the code?\n\n```java\nList<Integer> list = new ArrayList<>();\nlist.add(10);\nlist.add(20);\nlist.add(30);\nlist.add(40);\nlist.remove(Integer.valueOf(20));\nSystem.out.println(list);\n```\n",
    code: "List<Integer> list = new ArrayList<>();\nlist.add(10);\nlist.add(20);\nlist.add(30);\nlist.add(40);\nlist.remove(Integer.valueOf(20));\nSystem.out.println(list);",
    answers: ["[10, 30, 40]", "[10, 20, 30, 40]", "[10, 30]", "[20, 30, 40]"],
    correct: 0,
    explanations: [
      "The output of the code will be [10, 30, 40]. The remove() method in ArrayList removes the first occurrence of the specified element from the list, which in this case is '20', resulting in the list [10, 30, 40].",
      "Option [10, 20, 30, 40] is incorrect because it includes '20', which has been removed from the list.",
      "Option [10, 30] is incorrect because it does not include '40', which is part of the list after the remove() operation.",
      "Option [20, 30, 40] is incorrect because it includes '20', which has been removed from the list.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 60,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.3,
    question:
      "Consider the following Java code snippet. What will be the output of the code?\n\n```java\nStack<Integer> stack = new Stack<>();\nstack.push(5);\nstack.push(10);\nstack.push(15);\nstack.pop();\nSystem.out.println(stack);\n```\n",
    code: "Stack<Integer> stack = new Stack<>();\nstack.push(5);\nstack.push(10);\nstack.push(15);\nstack.pop();\nSystem.out.println(stack);",
    answers: ["[5, 10]", "[10, 15]", "[5, 15]", "[10]"],
    correct: 0,
    explanations: [
      "Option [10, 15] is incorrect because it includes '10', which is not the correct output.",
      "Option [5, 15] is incorrect because it includes '5', which is not the correct output.",
      "Option [10] is incorrect because it only includes '10', which is not the correct output.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 60,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.3,
    question:
      'Consider the following Java code snippet. What will be the output of the code?\n\n```java\nList<String> list = new ArrayList<>();\nlist.add("dog");\nlist.add("cat");\nlist.add("rabbit");\nlist.remove(1);\nSystem.out.println(list);\n```\n',
    code: 'List<String> list = new ArrayList<>();\nlist.add("dog");\nlist.add("cat");\nlist.add("rabbit");\nlist.remove(1);\nSystem.out.println(list);',
    answers: [
      "[dog, rabbit]",
      "[dog, cat, rabbit]",
      "[rabbit]",
      "[cat, rabbit]",
    ],
    correct: 0,
    explanations: [
      "Option [dog, cat, rabbit] is incorrect because it includes 'cat', which should be removed from the list.",
      "Option [rabbit] is incorrect because it only includes 'rabbit', which is not the correct output.",
      "Option [cat, rabbit] is incorrect because it includes 'cat', which should be removed from the list.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 60,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.3,
    question:
      "Consider the following Java code snippet. What will be the output of the code?\n\n```java\nQueue<Integer> queue = new LinkedList<>();\nqueue.add(10);\nqueue.add(20);\nqueue.remove();\nqueue.add(30);\nSystem.out.println(queue);\n```\n",
    code: "Queue<Integer> queue = new LinkedList<>();\nqueue.add(10);\nqueue.add(20);\nqueue.remove();\nqueue.add(30);\nSystem.out.println(queue);",
    answers: ["[20, 30]", "[10, 30]", "[10, 20, 30]", "[30]"],
    correct: 0,
    explanations: [
      "Option [10, 30] is incorrect because it includes '10', which should be removed from the queue.",
      "Option [10, 20, 30] is incorrect because it includes '10', which should be removed from the queue.",
      "Option [30] is incorrect because it only includes '30', which is not the correct output.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 60,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.3,
    question:
      'Consider the following Java code snippet. What will be the output of the code?\n\n```java\nStack<String> stack = new Stack<>();\nstack.push("sun");\nstack.push("moon");\nstack.pop();\nstack.push("star");\nSystem.out.println(stack);\n```\n',
    code: 'Stack<String> stack = new Stack<>();\nstack.push("sun");\nstack.push("moon");\nstack.pop();\nstack.push("star");\nSystem.out.println(stack);',
    answers: ["[sun, star]", "[sun, moon, star]", "[star]", "[moon, star]"],
    correct: 0,
    explanations: [
      "Option [sun, moon, star] is incorrect because it includes 'moon', which should be removed from the stack.",
      "Option [star] is incorrect because it only includes 'star', which is not the correct output.",
      "Option [moon, star] is incorrect because it includes 'moon', which should be removed from the stack.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 60,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.3,
    question:
      "Consider the following Java code snippet. What will be the output of the code?\n\n```java\nList<Integer> list = new ArrayList<>();\nlist.add(100);\nlist.add(200);\nlist.add(300);\nlist.remove(2);\nSystem.out.println(list);\n```\n",
    code: "List<Integer> list = new ArrayList<>();\nlist.add(100);\nlist.add(200);\nlist.add(300);\nlist.remove(2);\nSystem.out.println(list);",
    answers: ["[100, 200]", "[100, 300]", "[200, 300]", "[100, 200, 300]"],
    correct: 0,
    explanations: [
      "Option [100, 300] is incorrect because it includes '300', which should be removed from the list.",
      "Option [200, 300] is incorrect because it includes '200', which should not be removed from the list.",
      "Option [100, 200, 300] is incorrect because it includes '200' and '300', one of which should be removed from the list.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 60,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.3,
    question:
      'Consider the following Java code snippet. What will be the output of the code?\n\n```java\nQueue<String> queue = new LinkedList<>();\nqueue.add("apple");\nqueue.add("banana");\nqueue.remove();\nqueue.add("orange");\nSystem.out.println(queue);\n```\n',
    code: 'Queue<String> queue = new LinkedList<>();\nqueue.add("apple");\nqueue.add("banana");\nqueue.remove();\nqueue.add("orange");\nSystem.out.println(queue);',
    answers: ["[banana, orange]", "[apple, orange]", "[orange]", "[banana]"],
    correct: 0,
    explanations: [
      "Option [apple, orange] is incorrect because it includes 'apple', which should be removed from the queue.",
      "Option [orange] is incorrect because it only includes 'orange', which is not the correct output.",
      "Option [banana] is incorrect because it only includes 'banana', which should not be the only element in the queue.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 60,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.6,
    question:
      "Which data structure in Java would be most suitable for implementing a LIFO (Last In, First Out) behavior?",
    answers: ["Stack", "Queue", "ArrayList", "LinkedList"],
    correct: 0,
    explanations: [
      "Option Queue is incorrect because it does not implement the LIFO behavior.",
      "Option ArrayList is incorrect because it does not implement the LIFO behavior.",
      "Option LinkedList is incorrect because it does not implement the LIFO behavior.",
    ],
    bloomTaxonomy: "Evaluating",
    timeTakenSeconds: 45,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.6,
    question:
      "Which method in Java's LinkedList class is used to add an element at the end of the list?",
    answers: ["addLast()", "addFirst()", "add()", "insertLast()"],
    correct: 0,
    explanations: [
      "Option addFirst() is incorrect because it adds an element at the beginning of the list.",
      "Option add() is incorrect because it adds an element at the specified index, not necessarily at the end of the list.",
      "Option insertLast() is incorrect because there is no such method in Java's LinkedList class.",
    ],
    bloomTaxonomy: "Evaluating",
    timeTakenSeconds: 40,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.6,
    question: "Which Java interface provides a standard queue behavior?",
    answers: ["Queue", "List", "Deque", "Map"],
    correct: 0,
    explanations: [
      "Option List is incorrect because it does not provide a standard queue behavior.",
      "Option Deque is incorrect because it does not provide a standard queue behavior.",
      "Option Map is incorrect because it does not provide a standard queue behavior.",
    ],
    bloomTaxonomy: "Evaluating",
    timeTakenSeconds: 35,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.6,
    question:
      "Which method in Java's ArrayList class is used to remove an element at a specific index?",
    answers: [
      "remove(int index)",
      "remove(Object o)",
      "delete(int index)",
      "pop(int index)",
    ],
    correct: 0,
    explanations: [
      "Option remove(Object o) is incorrect because it removes the first occurrence of the specified element, not an element at a specific index.",
      "Option delete(int index) is incorrect because there is no such method in Java's ArrayList class.",
      "Option pop(int index) is incorrect because there is no such method in Java's ArrayList class.",
    ],
    bloomTaxonomy: "Evaluating",
    timeTakenSeconds: 40,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.6,
    question:
      "Which Java collection provides an implementation of the Queue interface with additional functionality?",
    answers: ["LinkedList", "Stack", "HashSet", "TreeSet"],
    correct: 0,
    explanations: [
      "The correct answer is LinkedList. LinkedList in Java provides an implementation of the Queue interface along with additional functionality.",
      "Option Stack is incorrect because Stack does not provide an implementation of the Queue interface.",
      "Option HashSet is incorrect because HashSet does not provide an implementation of the Queue interface.",
      "Option TreeSet is incorrect because TreeSet does not provide an implementation of the Queue interface.",
    ],
    bloomTaxonomy: "Evaluating",
    timeTakenSeconds: 45,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.6,
    question:
      "Which method in Java's Stack class is used to retrieve but not remove the top element of the stack?",
    answers: ["peek()", "pop()", "getTop()", "top()"],
    correct: 0,
    explanations: [
      "The correct answer is peek(). This method is used to retrieve but not remove the top element of the stack.",
      "Option pop() is incorrect because pop() removes and returns the top element of the stack.",
      "Option getTop() is incorrect because there is no such method in Java's Stack class.",
      "Option top() is incorrect because there is no such method in Java's Stack class.",
    ],
    bloomTaxonomy: "Evaluating",
    timeTakenSeconds: 40,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.6,
    question:
      "Which Java interface extends the Queue interface and adds support for operations that access elements at both ends of the queue?",
    answers: ["Deque", "List", "Map", "Set"],
    correct: 0,
    explanations: [
      "The correct answer is Deque. Deque interface in Java extends the Queue interface and adds support for operations that access elements at both ends of the queue.",
      "Option List is incorrect because List does not extend the Queue interface.",
      "Option Map is incorrect because Map does not extend the Queue interface.",
      "Option Set is incorrect because Set does not extend the Queue interface.",
    ],
    bloomTaxonomy: "Evaluating",
    timeTakenSeconds: 35,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.6,
    question:
      "Which method in Java's ArrayList class is used to add an element at a specific index?",
    answers: [
      "add(int index, E element)",
      "add(E element)",
      "insert(int index, E element)",
      "push(int index, E element)",
    ],
    correct: 0,
    explanations: [
      "The correct answer is add(int index, E element). This method is used to add the specified element at the specified index in the ArrayList.",
      "Option add(E element) is incorrect because it adds the element to the end of the ArrayList, not at a specific index.",
      "Option insert(int index, E element) is incorrect because there is no such method in Java's ArrayList class.",
      "Option push(int index, E element) is incorrect because there is no such method in Java's ArrayList class.",
    ],
    bloomTaxonomy: "Evaluating",
    timeTakenSeconds: 40,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.6,
    question:
      "Which Java collection class provides a resizable array implementation?",
    answers: ["ArrayList", "LinkedList", "HashSet", "HashMap"],
    correct: 0,
    explanations: [
      "The correct answer is ArrayList. ArrayList in Java provides a resizable array implementation.",
      "Option LinkedList is incorrect because LinkedList does not provide a resizable array implementation.",
      "Option HashSet is incorrect because HashSet does not provide a resizable array implementation.",
      "Option HashMap is incorrect because HashMap does not provide a resizable array implementation.",
    ],
    bloomTaxonomy: "Evaluating",
    timeTakenSeconds: 35,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.6,
    question:
      "Which Java collection class allows duplicate elements and maintains the insertion order?",
    answers: ["ArrayList", "HashSet", "HashMap", "TreeSet"],
    correct: 0,
    explanations: [
      "The correct answer is ArrayList. ArrayList in Java allows duplicate elements and maintains the insertion order.",
      "Option HashSet is incorrect because HashSet does not maintain the insertion order.",
      "Option HashMap is incorrect because HashMap does not maintain the insertion order.",
      "Option TreeSet is incorrect because TreeSet does not allow duplicate elements.",
    ],
    bloomTaxonomy: "Evaluating",
    timeTakenSeconds: 35,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.6,
    question:
      "Which method in Java's LinkedList class is used to remove the first occurrence of a specified element?",
    answers: [
      "remove(Object o)",
      "removeFirst()",
      "remove()",
      "delete(Object o)",
    ],
    correct: 0,
    explanations: [
      "The correct answer is remove(Object o). This method is used to remove the first occurrence of the specified element from the LinkedList.",
      "Option removeFirst() is incorrect because it removes the first element of the list, not a specific occurrence of an element.",
      "Option remove() is incorrect because it removes the first element of the list, not a specific occurrence of an element.",
      "Option delete(Object o) is incorrect because there is no such method in Java's LinkedList class.",
    ],
    bloomTaxonomy: "Evaluating",
    timeTakenSeconds: 40,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.7,
    question:
      "Which data structure in Java would be most suitable for implementing a FIFO (First In, First Out) behavior?",
    answers: ["Queue", "Stack", "ArrayList", "LinkedList"],
    correct: 0,
    explanations: [
      "The correct answer is Queue. Queue implements the FIFO behavior, where the first element added is the first one to be removed.",
      "Option Stack is incorrect because Stack implements the LIFO behavior, not FIFO.",
      "Option ArrayList is incorrect because ArrayList does not guarantee FIFO behavior.",
      "Option LinkedList is incorrect because LinkedList does not guarantee FIFO behavior.",
    ],
    bloomTaxonomy: "Evaluating",
    timeTakenSeconds: 50,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.7,
    question:
      "Which method in Java's LinkedList class is used to add an element at the beginning of the list?",
    answers: ["addFirst()", "addLast()", "add()", "insertFirst()"],
    correct: 0,
    explanations: [
      "The correct answer is addFirst(). This method is used to add an element at the beginning of the LinkedList.",
      "Option addLast() is incorrect because it adds an element at the end of the list, not at the beginning.",
      "Option add() is incorrect because it adds an element at the end of the list, not at the beginning.",
      "Option insertFirst() is incorrect because there is no such method in Java's LinkedList class.",
    ],
    bloomTaxonomy: "Evaluating",
    timeTakenSeconds: 45,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.7,
    question: "Which Java interface provides a standard stack behavior?",
    answers: ["Stack", "List", "Deque", "Map"],
    correct: 0,
    explanations: [
      "The correct answer is Stack. Stack interface in Java provides a standard stack behavior, which follows the LIFO (Last In, First Out) principle.",
      "Option List is incorrect because List does not provide a standard stack behavior.",
      "Option Deque is incorrect because Deque does not provide a standard stack behavior.",
      "Option Map is incorrect because Map does not provide a standard stack behavior.",
    ],
    bloomTaxonomy: "Evaluating",
    timeTakenSeconds: 50,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.7,
    question:
      "Which method in Java's ArrayList class is used to remove all elements from the list?",
    answers: ["clear()", "removeAll()", "deleteAll()", "empty()"],
    correct: 0,
    explanations: [
      "The correct answer is clear(). This method is used to remove all elements from the ArrayList.",
      "Option removeAll() is incorrect because it removes all occurrences of a specified collection from the list, not all elements.",
      "Option deleteAll() is incorrect because there is no such method in Java's ArrayList class.",
      "Option empty() is incorrect because there is no such method in Java's ArrayList class.",
    ],
    bloomTaxonomy: "Evaluating",
    timeTakenSeconds: 45,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.7,
    question:
      "Which Java collection provides an implementation of the Deque interface with additional functionality?",
    answers: ["LinkedList", "ArrayList", "HashSet", "TreeSet"],
    correct: 0,
    explanations: [
      "The correct answer is LinkedList. LinkedList in Java provides an implementation of the Deque interface along with additional functionality.",
      "Option ArrayList is incorrect because ArrayList does not provide an implementation of the Deque interface.",
      "Option HashSet is incorrect because HashSet does not provide an implementation of the Deque interface.",
      "Option TreeSet is incorrect because TreeSet does not provide an implementation of the Deque interface.",
    ],
    bloomTaxonomy: "Evaluating",
    timeTakenSeconds: 50,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.7,
    question:
      "Which method in Java's Stack class is used to check if the stack is empty?",
    answers: ["empty()", "isEmpty()", "isStackEmpty()", "stackEmpty()"],
    correct: 1,
    explanations: [
      "The correct answer is isEmpty(). This method is used to check if the stack is empty.",
      "Option empty() is incorrect because there is no such method in Java's Stack class.",
      "Option isStackEmpty() is incorrect because there is no such method in Java's Stack class.",
      "Option stackEmpty() is incorrect because there is no such method in Java's Stack class.",
    ],
    bloomTaxonomy: "Evaluating",
    timeTakenSeconds: 45,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.7,
    question:
      "Which Java interface extends the Queue interface and adds support for operations that access elements at both ends of the deque?",
    answers: ["Deque", "List", "Map", "Set"],
    correct: 0,
    explanations: [
      "The correct answer is Deque. Deque interface in Java extends the Queue interface and adds support for operations that access elements at both ends of the deque.",
      "Option List is incorrect because List does not extend the Queue interface.",
      "Option Map is incorrect because Map does not extend the Queue interface.",
      "Option Set is incorrect because Set does not extend the Queue interface.",
    ],
    bloomTaxonomy: "Evaluating",
    timeTakenSeconds: 50,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.7,
    question:
      "Which method in Java's ArrayList class is used to retrieve the element at a specified index?",
    answers: [
      "get(int index)",
      "retrieve(int index)",
      "elementAt(int index)",
      "access(int index)",
    ],
    correct: 0,
    explanations: [
      "The correct answer is get(int index). This method is used to retrieve the element at the specified index in the ArrayList.",
      "Option retrieve(int index) is incorrect because there is no such method in Java's ArrayList class.",
      "Option elementAt(int index) is incorrect because there is no such method in Java's ArrayList class.",
      "Option access(int index) is incorrect because there is no such method in Java's ArrayList class.",
    ],
    bloomTaxonomy: "Evaluating",
    timeTakenSeconds: 45,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.7,
    question:
      "Which Java collection class provides an implementation of the Set interface?",
    answers: ["HashSet", "ArrayList", "LinkedList", "TreeSet"],
    correct: 0,
    explanations: [
      "The correct answer is HashSet. HashSet in Java provides an implementation of the Set interface.",
      "Option ArrayList is incorrect because ArrayList does not provide an implementation of the Set interface.",
      "Option LinkedList is incorrect because LinkedList does not provide an implementation of the Set interface.",
      "Option TreeSet is incorrect because TreeSet does not provide an implementation of the Set interface.",
    ],
    bloomTaxonomy: "Evaluating",
    timeTakenSeconds: 50,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.7,
    question:
      "Which Java collection class allows unique elements only and does not maintain the insertion order?",
    answers: ["HashSet", "ArrayList", "LinkedList", "TreeSet"],
    correct: 0,
    explanations: [
      "The correct answer is HashSet. HashSet in Java allows unique elements only and does not maintain the insertion order.",
      "Option ArrayList is incorrect because ArrayList allows duplicate elements and maintains the insertion order.",
      "Option LinkedList is incorrect because LinkedList allows duplicate elements and maintains the insertion order.",
      "Option TreeSet is incorrect because TreeSet allows unique elements only and maintains the natural order or the order specified by a Comparator.",
    ],
    bloomTaxonomy: "Evaluating",
    timeTakenSeconds: 50,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.7,
    question:
      "Which method in Java's LinkedList class is used to remove the last element of the list?",
    answers: ["removeLast()", "remove()", "deleteLast()", "pop()"],
    correct: 0,
    explanations: [
      "The correct answer is removeLast(). This method is used to remove the last element of the LinkedList.",
      "Option remove() is incorrect because it removes the first occurrence of a specified element, not the last element of the list.",
      "Option deleteLast() is incorrect because there is no such method in Java's LinkedList class.",
      "Option pop() is incorrect because there is no such method in Java's LinkedList class.",
    ],
    bloomTaxonomy: "Evaluating",
    timeTakenSeconds: 45,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.5,
    question:
      "Which data structure in Java is used to store a collection of elements in a sequence?",
    answers: ["List", "Queue", "Stack", "Set"],
    correct: 0,
    explanations: [
      "The correct answer is List. List in Java is used to store a collection of elements in a sequence.",
      "Option Queue is incorrect because Queue is used to store elements with FIFO behavior, not in a sequence.",
      "Option Stack is incorrect because Stack is used to store elements with LIFO behavior, not in a sequence.",
      "Option Set is incorrect because Set does not maintain the insertion order of elements.",
    ],
    bloomTaxonomy: "Evaluating",
    timeTakenSeconds: 30,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.5,
    question:
      "Which method in Java's LinkedList class is used to add an element at the end of the list?",
    answers: ["add()", "addLast()", "append()", "insertLast()"],
    correct: 1,
    explanations: [
      "The correct answer is addLast(). This method is used to add an element at the end of the LinkedList.",
      "Option add() is incorrect because it adds an element at the end of the list, but addLast() is specifically designed for this purpose.",
      "Option append() is incorrect because there is no such method in Java's LinkedList class.",
      "Option insertLast() is incorrect because there is no such method in Java's LinkedList class.",
    ],
    bloomTaxonomy: "Evaluating",
    timeTakenSeconds: 35,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.5,
    question: "Which Java interface provides a standard queue behavior?",
    answers: ["Queue", "List", "Deque", "Stack"],
    correct: 0,
    explanations: [
      "The correct answer is Queue. Queue interface in Java provides a standard queue behavior, which follows the FIFO (First In, First Out) principle.",
      "Option List is incorrect because List does not provide a standard queue behavior.",
      "Option Deque is incorrect because Deque does not provide a standard queue behavior.",
      "Option Stack is incorrect because Stack provides LIFO (Last In, First Out) behavior, not FIFO.",
    ],
    bloomTaxonomy: "Evaluating",
    timeTakenSeconds: 30,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.5,
    question:
      "Which method in Java's ArrayList class is used to remove an element at a specific index?",
    answers: [
      "remove(int index)",
      "delete(int index)",
      "removeAtIndex(int index)",
      "pop(int index)",
    ],
    correct: 0,
    explanations: [
      "The correct answer is remove(int index). This method is used to remove the element at the specified index from the ArrayList.",
      "Option delete(int index) is incorrect because there is no such method in Java's ArrayList class.",
      "Option removeAtIndex(int index) is incorrect because there is no such method in Java's ArrayList class.",
      "Option pop(int index) is incorrect because there is no such method in Java's ArrayList class.",
    ],
    bloomTaxonomy: "Evaluating",
    timeTakenSeconds: 35,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.5,
    question:
      "Which Java collection class provides an implementation of the Stack interface?",
    answers: ["Stack", "Queue", "List", "Deque"],
    correct: 0,
    explanations: [
      "The correct answer is Stack. Stack in Java provides an implementation of the Stack interface.",
      "Option Queue is incorrect because Queue does not provide an implementation of the Stack interface.",
      "Option List is incorrect because List does not provide an implementation of the Stack interface.",
      "Option Deque is incorrect because Deque does not provide an implementation of the Stack interface.",
    ],
    bloomTaxonomy: "Evaluating",
    timeTakenSeconds: 30,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.5,
    question:
      "Which method in Java's Stack class is used to retrieve but not remove the top element of the stack?",
    answers: ["peek()", "pop()", "top()", "getTop()"],
    correct: 0,
    explanations: [
      "The correct answer is peek(). This method is used to retrieve but not remove the top element of the stack.",
      "Option pop() is incorrect because pop() removes and returns the top element of the stack.",
      "Option top() is incorrect because there is no such method in Java's Stack class.",
      "Option getTop() is incorrect because there is no such method in Java's Stack class.",
    ],
    bloomTaxonomy: "Evaluating",
    timeTakenSeconds: 35,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.5,
    question:
      "Which Java interface extends the Queue interface and adds support for operations that access elements at both ends of the queue?",
    answers: ["Deque", "List", "Map", "Set"],
    correct: 0,
    explanations: [
      "The correct answer is Deque. Deque interface in Java extends the Queue interface and adds support for operations that access elements at both ends of the queue.",
      "Option List is incorrect because List does not extend the Queue interface.",
      "Option Map is incorrect because Map does not extend the Queue interface.",
      "Option Set is incorrect because Set does not extend the Queue interface.",
    ],
    bloomTaxonomy: "Evaluating",
    timeTakenSeconds: 30,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.5,
    question:
      "Which method in Java's ArrayList class is used to add an element at a specific index?",
    answers: [
      "add(int index, E element)",
      "add(E element)",
      "insert(int index, E element)",
      "push(int index, E element)",
    ],
    correct: 0,
    explanations: [
      "The correct answer is add(int index, E element). This method is used to add the specified element at the specified index in the ArrayList.",
      "Option add(E element) is incorrect because it adds the element to the end of the ArrayList, not at a specific index.",
      "Option insert(int index, E element) is incorrect because there is no such method in Java's ArrayList class.",
      "Option push(int index, E element) is incorrect because there is no such method in Java's ArrayList class.",
    ],
    bloomTaxonomy: "Evaluating",
    timeTakenSeconds: 30,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.5,
    question:
      "Which Java collection class provides a resizable array implementation?",
    answers: ["ArrayList", "LinkedList", "HashSet", "HashMap"],
    correct: 0,
    explanations: [
      "The correct answer is ArrayList. ArrayList in Java provides a resizable array implementation.",
      "Option LinkedList is incorrect because LinkedList does not provide a resizable array implementation.",
      "Option HashSet is incorrect because HashSet does not provide a resizable array implementation.",
      "Option HashMap is incorrect because HashMap does not provide a resizable array implementation.",
    ],
    bloomTaxonomy: "Evaluating",
    timeTakenSeconds: 35,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.5,
    question:
      "Which Java collection class allows duplicate elements and maintains the insertion order?",
    answers: ["ArrayList", "HashSet", "HashMap", "TreeSet"],
    correct: 0,
    explanations: [
      "The correct answer is ArrayList. ArrayList in Java allows duplicate elements and maintains the insertion order.",
      "Option HashSet is incorrect because HashSet does not maintain the insertion order.",
      "Option HashMap is incorrect because HashMap does not maintain the insertion order.",
      "Option TreeSet is incorrect because TreeSet does not allow duplicate elements.",
    ],
    bloomTaxonomy: "Evaluating",
    timeTakenSeconds: 30,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.5,
    question:
      "Which method in Java's LinkedList class is used to remove the first occurrence of a specified element?",
    answers: [
      "remove(Object o)",
      "removeFirst()",
      "remove()",
      "delete(Object o)",
    ],
    correct: 0,
    explanations: [
      "The correct answer is remove(Object o). This method is used to remove the first occurrence of the specified element from the LinkedList.",
      "Option removeFirst() is incorrect because it removes the first element of the list, not a specific occurrence of an element.",
      "Option remove() is incorrect because it removes the first element of the list, not a specific occurrence of an element.",
      "Option delete(Object o) is incorrect because there is no such method in Java's LinkedList class.",
    ],
    bloomTaxonomy: "Evaluating",
    timeTakenSeconds: 35,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.6,
    question:
      "Which method in Java's Queue interface is used to retrieve but not remove the head of the queue?",
    answers: ["peek()", "poll()", "remove()", "element()"],
    correct: 0,
    explanations: [
      "The correct answer is peek(). This method is used to retrieve but not remove the head of the queue.",
      "Option poll() is incorrect because poll() retrieves and removes the head of the queue.",
      "Option remove() is incorrect because remove() retrieves and removes the head of the queue, throwing an exception if the queue is empty.",
      "Option element() is incorrect because element() retrieves but does not remove the head of the queue, throwing an exception if the queue is empty.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 40,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.6,
    question:
      "Which method in Java's Stack class is used to push an element onto the stack?",
    answers: ["push()", "add()", "insert()", "append()"],
    correct: 0,
    explanations: [
      "The correct answer is push(). This method is used to push an element onto the stack.",
      "Option add() is incorrect because add() is used to add an element to a collection, not specifically onto a stack.",
      "Option insert() is incorrect because there is no such method in Java's Stack class.",
      "Option append() is incorrect because append() is used in the context of appending one string to another, not pushing onto a stack.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 45,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.6,
    question:
      "Which Java collection class allows elements to be accessed based on their insertion order?",
    answers: ["ArrayList", "HashMap", "HashSet", "LinkedHashMap"],
    correct: 3,
    explanations: [
      "The correct answer is LinkedHashMap. LinkedHashMap in Java allows elements to be accessed based on their insertion order.",
      "Option ArrayList is incorrect because ArrayList allows random access based on index, not insertion order.",
      "Option HashMap is incorrect because HashMap does not guarantee any specific order for its elements.",
      "Option HashSet is incorrect because HashSet does not maintain the insertion order of its elements.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 40,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.6,
    question:
      "Which Java interface provides a collection of elements with no duplicates and no specific order?",
    answers: ["Set", "List", "Queue", "Deque"],
    correct: 0,
    explanations: [
      "The correct answer is Set. Set interface in Java provides a collection of elements with no duplicates and no specific order.",
      "Option List is incorrect because List allows duplicate elements and maintains the insertion order.",
      "Option Queue is incorrect because Queue follows FIFO behavior and does not guarantee uniqueness or order.",
      "Option Deque is incorrect because Deque provides a double-ended queue and does not guarantee uniqueness or order.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 35,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.6,
    question:
      "Which method in Java's LinkedList class is used to add an element at the specified index?",
    answers: [
      "add(int index, E element)",
      "insert(int index, E element)",
      "addAtIndex(int index, E element)",
      "push(int index, E element)",
    ],
    correct: 0,
    explanations: [
      "The correct answer is add(int index, E element). This method is used to add the specified element at the specified index in the LinkedList.",
      "Option insert(int index, E element) is incorrect because there is no such method in Java's LinkedList class.",
      "Option addAtIndex(int index, E element) is incorrect because there is no such method in Java's LinkedList class.",
      "Option push(int index, E element) is incorrect because push() adds the element to the beginning of the LinkedList, not at a specific index.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 40,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.6,
    question:
      "Which Java collection class maintains the elements in sorted order?",
    answers: ["TreeSet", "LinkedHashSet", "HashSet", "HashMap"],
    correct: 0,
    explanations: [
      "The correct answer is TreeSet. TreeSet in Java maintains the elements in sorted order.",
      "Option LinkedHashSet is incorrect because LinkedHashSet maintains the insertion order, not sorted order.",
      "Option HashSet is incorrect because HashSet does not maintain any specific order for its elements.",
      "Option HashMap is incorrect because HashMap does not maintain any specific order for its elements.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 45,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.6,
    question:
      "Which method in Java's Queue interface is used to remove and return the head of the queue?",
    answers: ["poll()", "remove()", "pop()", "dequeue()"],
    correct: 0,
    explanations: [
      "The correct answer is poll(). This method is used to remove and return the head of the queue.",
      "Option remove() is incorrect because remove() removes and returns the head of the queue, throwing an exception if the queue is empty.",
      "Option pop() is incorrect because pop() is not a method in Java's Queue interface.",
      "Option dequeue() is incorrect because dequeue() is not a method in Java's Queue interface.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 40,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.7,
    question:
      "Which Java collection class allows elements to be accessed in a LIFO (Last-In, First-Out) order?",
    answers: ["Stack", "LinkedList", "ArrayList", "HashSet"],
    correct: 0,
    explanations: [
      "The correct answer is Stack. Stack in Java allows elements to be accessed in a LIFO (Last-In, First-Out) order.",
      "Option LinkedList is incorrect because LinkedList allows elements to be accessed in the order they were added, not LIFO.",
      "Option ArrayList is incorrect because ArrayList allows elements to be accessed by index, not LIFO order.",
      "Option HashSet is incorrect because HashSet does not maintain any specific order for its elements.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 50,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.7,
    question: "Which Java interface provides a double-ended queue?",
    answers: ["Deque", "List", "Queue", "Stack"],
    correct: 0,
    explanations: [
      "The correct answer is Deque. Deque interface in Java provides a double-ended queue.",
      "Option List is incorrect because List does not specifically provide functionality for a double-ended queue.",
      "Option Queue is incorrect because Queue specifically provides functionality for a single-ended queue.",
      "Option Stack is incorrect because Stack provides functionality for a LIFO structure, not a double-ended queue.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 45,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.7,
    question:
      "Which method in Java's Stack class is used to check the element at the top of the stack without removing it?",
    answers: ["peek()", "top()", "getTop()", "element()"],
    correct: 0,
    explanations: [
      "The correct answer is peek(). This method is used to check the element at the top of the stack without removing it.",
      "Option top() is incorrect because there is no such method in Java's Stack class.",
      "Option getTop() is incorrect because there is no such method in Java's Stack class.",
      "Option element() is incorrect because element() is used in Java's Queue interface, not Stack, to retrieve but not remove the head of the queue.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 50,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.7,
    question:
      "Which method in Java's ArrayList class is used to add all elements of a collection at the end of the list?",
    answers: [
      "addAll(Collection<? extends E> c)",
      "addAll(int index, Collection<? extends E> c)",
      "insertAll(Collection<? extends E> c)",
      "pushAll(Collection<? extends E> c)",
    ],
    correct: 0,
    explanations: [
      "The correct answer is addAll(Collection<? extends E> c). This method is used to add all elements of a collection at the end of the list.",
      "Option addAll(int index, Collection<? extends E> c) is incorrect because it adds all elements of a collection starting from a specific index, not necessarily at the end of the list.",
      "Option insertAll(Collection<? extends E> c) is incorrect because there is no such method in Java's ArrayList class.",
      "Option pushAll(Collection<? extends E> c) is incorrect because there is no such method in Java's ArrayList class.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 55,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.8,
    question:
      "Which Java collection class provides a balanced binary tree implementation?",
    answers: ["TreeSet", "HashMap", "LinkedHashSet", "PriorityQueue"],
    correct: 0,
    explanations: [
      "The correct answer is TreeSet. TreeSet in Java provides a balanced binary tree implementation.",
      "Option HashMap is incorrect because HashMap does not use a balanced binary tree implementation.",
      "Option LinkedHashSet is incorrect because LinkedHashSet maintains insertion order, not a balanced binary tree structure.",
      "Option PriorityQueue is incorrect because PriorityQueue uses a priority heap, not a balanced binary tree.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 60,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.8,
    question:
      "Which method in Java's PriorityQueue class is used to retrieve and remove the highest priority element?",
    answers: ["poll()", "peek()", "remove()", "pop()"],
    correct: 0,
    explanations: [
      "The correct answer is poll(). This method is used to retrieve and remove the highest priority element from the PriorityQueue.",
      "Option peek() is incorrect because peek() retrieves but does not remove the highest priority element.",
      "Option remove() is incorrect because remove() removes and returns a specified element, not necessarily the highest priority one.",
      "Option pop() is incorrect because pop() is not a method in Java's PriorityQueue class.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 60,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.8,
    question:
      "Which Java interface extends the Collection interface and maintains the insertion order?",
    answers: ["List", "Set", "Queue", "Deque"],
    correct: 0,
    explanations: [
      "The correct answer is List. List interface in Java extends the Collection interface and maintains the insertion order.",
      "Option Set is incorrect because Set does not maintain insertion order.",
      "Option Queue is incorrect because Queue follows FIFO order, not necessarily insertion order.",
      "Option Deque is incorrect because Deque provides functionality for a double-ended queue and does not specifically maintain insertion order.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 60,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.8,
    question:
      "Which method in Java's LinkedList class is used to add an element at the end of the list?",
    answers: ["offerLast()", "push()", "addLast()", "enqueue()"],
    correct: 2,
    explanations: [
      "The correct answer is addLast(). This method is used to add an element at the end of the LinkedList.",
      "Option offerLast() is incorrect because offerLast() adds an element to the end of the queue, not specifically to the end of the list.",
      "Option push() is incorrect because push() adds an element to the beginning of the list, not the end.",
      "Option enqueue() is incorrect because enqueue() is not a method in Java's LinkedList class.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 60,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.8,
    question:
      "Which Java interface provides a double-ended queue that supports element insertion and removal at both ends?",
    answers: ["Deque", "List", "Queue", "Stack"],
    correct: 0,
    explanations: [
      "The correct answer is Deque. Deque interface in Java provides a double-ended queue that supports element insertion and removal at both ends.",
      "Option List is incorrect because List does not specifically provide functionality for a double-ended queue.",
      "Option Queue is incorrect because Queue specifically provides functionality for a single-ended queue.",
      "Option Stack is incorrect because Stack provides functionality for a LIFO structure, not a double-ended queue.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 60,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.8,
    question:
      "Which method in Java's PriorityQueue class is used to check if the queue is empty?",
    answers: ["isEmpty()", "empty()", "isQueueEmpty()", "queueEmpty()"],
    correct: 0,
    explanations: [
      "The correct answer is isEmpty(). This method is used to check if the PriorityQueue is empty.",
      "Option empty() is incorrect because there is no such method in Java's PriorityQueue class.",
      "Option isQueueEmpty() is incorrect because there is no such method in Java's PriorityQueue class.",
      "Option queueEmpty() is incorrect because there is no such method in Java's PriorityQueue class.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 60,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.9,
    question:
      "Which Java collection class provides a constant-time performance for the basic operations like add, remove, and contains?",
    answers: ["LinkedHashSet", "HashMap", "ArrayList", "TreeSet"],
    correct: 1,
    explanations: [
      "The correct answer is HashMap. HashMap in Java provides constant-time performance for the basic operations like add, remove, and contains, on average.",
      "Option LinkedHashSet is incorrect because LinkedHashSet maintains insertion order but does not guarantee constant-time performance.",
      "Option ArrayList is incorrect because ArrayList does not provide constant-time performance for all operations.",
      "Option TreeSet is incorrect because TreeSet maintains elements in sorted order but does not guarantee constant-time performance.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 60,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.9,
    question:
      "Which method in Java's Stack class is used to search for an element and return its position relative to the top of the stack?",
    answers: [
      "search(Object o)",
      "find(Object o)",
      "position(Object o)",
      "locate(Object o)",
    ],
    correct: 0,
    explanations: [
      "The correct answer is search(Object o). This method is used to search for an element and return its position relative to the top of the stack.",
      "Option find(Object o) is incorrect because there is no such method in Java's Stack class.",
      "Option position(Object o) is incorrect because there is no such method in Java's Stack class.",
      "Option locate(Object o) is incorrect because there is no such method in Java's Stack class.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 60,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.9,
    question:
      "Which method in Java's LinkedList class is used to remove and return the last element of the list?",
    answers: ["pollLast()", "removeLast()", "pop()", "dequeueLast()"],
    correct: 1,
    explanations: [
      "The correct answer is removeLast(). This method is used to remove and return the last element of the LinkedList.",
      "Option pollLast() is incorrect because pollLast() retrieves and removes the last element, but does not return it.",
      "Option pop() is incorrect because pop() is not a method in Java's LinkedList class.",
      "Option dequeueLast() is incorrect because dequeueLast() is not a method in Java's LinkedList class.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 60,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.9,
    question:
      "Which Java collection class allows for key-value pairs and does not allow duplicate keys?",
    answers: ["HashMap", "Hashtable", "LinkedHashMap", "TreeMap"],
    correct: 3,
    explanations: [
      "The correct answer is TreeMap. TreeMap in Java allows for key-value pairs and does not allow duplicate keys.",
      "Option HashMap is incorrect because HashMap allows for key-value pairs and allows duplicate keys.",
      "Option Hashtable is incorrect because Hashtable does not allow null keys or values.",
      "Option LinkedHashMap is incorrect because LinkedHashMap maintains insertion order but does not restrict duplicate keys.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 60,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.9,
    question:
      "Which method in Java's Stack class is used to remove all elements from the stack?",
    answers: ["removeAll()", "clear()", "empty()", "popAll()"],
    correct: 1,
    explanations: [
      "The correct answer is clear(). This method is used to remove all elements from the Stack.",
      "Option removeAll() is incorrect because removeAll() is not a method in Java's Stack class.",
      "Option empty() is incorrect because empty() is used to check if the stack is empty, not to remove its elements.",
      "Option popAll() is incorrect because popAll() is not a method in Java's Stack class.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 60,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.9,
    question:
      "Which method in Java's LinkedList class is used to add an element at the beginning of the list?",
    answers: ["addFirst()", "insertFirst()", "push()", "prepend()"],
    correct: 0,
    explanations: [
      "The correct answer is addFirst(). This method is used to add an element at the beginning of the LinkedList.",
      "Option insertFirst() is incorrect because there is no such method in Java's LinkedList class.",
      "Option push() is incorrect because push() adds an element to the beginning of the list in Java's Stack class, not LinkedList.",
      "Option prepend() is incorrect because there is no such method in Java's LinkedList class.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 60,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.9,
    question:
      "Which Java collection class provides a queue that orders elements based on their natural ordering or the ordering specified by a Comparator?",
    answers: ["PriorityQueue", "LinkedList", "ArrayDeque", "HashSet"],
    correct: 0,
    explanations: [
      "The correct answer is PriorityQueue. PriorityQueue in Java provides a queue that orders elements based on their natural ordering or the ordering specified by a Comparator.",
      "Option LinkedList is incorrect because LinkedList does not necessarily order elements according to a Comparator.",
      "Option ArrayDeque is incorrect because ArrayDeque does not order elements based on a Comparator.",
      "Option HashSet is incorrect because HashSet does not maintain order.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 60,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.9,
    question:
      "Which method in Java's Stack class is used to push an element onto the top of the stack?",
    answers: [
      "push(E item)",
      "add(E item)",
      "insert(E item)",
      "append(E item)",
    ],
    correct: 0,
    explanations: [
      "The correct answer is push(E item). This method is used to push an element onto the top of the stack in Java's Stack class.",
      "Option add(E item) is incorrect because add(E item) adds an element to the end of the list, not the top of the stack.",
      "Option insert(E item) is incorrect because there is no such method in Java's Stack class.",
      "Option append(E item) is incorrect because there is no such method in Java's Stack class.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 60,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.9,
    question:
      "Which Java interface provides a collection that maintains order and allows duplicates?",
    answers: ["List", "Set", "Deque", "Queue"],
    correct: 0,
    explanations: [
      "The correct answer is List. List interface in Java provides a collection that maintains order and allows duplicates.",
      "Option Set is incorrect because Set does not allow duplicates.",
      "Option Deque is incorrect because Deque provides functionality for a double-ended queue but does not necessarily maintain order.",
      "Option Queue is incorrect because Queue provides functionality for a FIFO structure but does not necessarily maintain order.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 60,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.9,
    question:
      "Which method in Java's Queue interface is used to retrieve but not remove the head of the queue?",
    answers: ["peek()", "poll()", "remove()", "get()"],
    correct: 0,
    explanations: [
      "The correct answer is peek(). This method is used to retrieve but not remove the head of the queue in Java's Queue interface.",
      "Option poll() is incorrect because poll() retrieves and removes the head of the queue.",
      "Option remove() is incorrect because remove() removes and returns the head of the queue.",
      "Option get() is incorrect because there is no such method in Java's Queue interface.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 60,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.9,
    question: "Which Java collection class provides a LIFO structure?",
    answers: ["Stack", "LinkedList", "ArrayDeque", "HashSet"],
    correct: 0,
    explanations: [
      "The correct answer is Stack. Stack class in Java provides a LIFO (Last In, First Out) structure.",
      "Option LinkedList is incorrect because LinkedList does not enforce a LIFO structure.",
      "Option ArrayDeque is incorrect because ArrayDeque is typically used as a deque, not specifically as a stack.",
      "Option HashSet is incorrect because HashSet does not enforce any specific ordering of elements.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 60,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.9,
    question:
      "Which method in Java's Deque interface is used to insert an element at the front of the deque?",
    answers: [
      "offerFirst(E e)",
      "addFirst(E e)",
      "push(E e)",
      "insertFirst(E e)",
    ],
    correct: 1,
    explanations: [
      "The correct answer is addFirst(E e). This method is used to insert an element at the front of the deque in Java's Deque interface.",
      "Option offerFirst(E e) is incorrect because offerFirst(E e) adds an element to the front of the deque but does not necessarily succeed if the deque is full.",
      "Option push(E e) is incorrect because push(E e) adds an element to the front of the deque but specifically for stacks.",
      "Option insertFirst(E e) is incorrect because there is no such method in Java's Deque interface.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 60,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.9,
    question:
      "Which Java interface extends the Collection interface and allows removal and insertion of elements at both ends?",
    answers: ["Deque", "List", "Queue", "Set"],
    correct: 0,
    explanations: [
      "The correct answer is Deque. Deque interface in Java extends the Collection interface and allows removal and insertion of elements at both ends.",
      "Option List is incorrect because List allows access and modification of elements at any position, not specifically at both ends.",
      "Option Queue is incorrect because Queue allows insertion at one end and removal at the other, but not necessarily at both ends.",
      "Option Set is incorrect because Set does not allow duplicate elements and does not preserve insertion order, and it does not specifically support removal and insertion at both ends.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 60,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.9,
    question:
      "Which method in Java's Stack class is used to retrieve and remove the top element of the stack?",
    answers: ["peek()", "pop()", "remove()", "getTop()"],
    correct: 1,
    explanations: [
      "The correct answer is pop(). This method is used to retrieve and remove the top element of the stack in Java's Stack class.",
      "Option peek() is incorrect because peek() retrieves but does not remove the top element of the stack.",
      "Option remove() is incorrect because there is no such method in Java's Stack class.",
      "Option getTop() is incorrect because there is no such method in Java's Stack class.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 60,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.9,
    question:
      "Which Java collection class provides a data structure that allows rapid retrieval of elements based on their keys?",
    answers: ["HashMap", "TreeMap", "LinkedHashMap", "HashSet"],
    correct: 1,
    explanations: [
      "The correct answer is TreeMap. TreeMap in Java provides a data structure that allows rapid retrieval of elements based on their keys.",
      "Option HashMap is incorrect because HashMap does not necessarily maintain order.",
      "Option LinkedHashMap is incorrect because LinkedHashMap maintains insertion order but does not order elements based on keys.",
      "Option HashSet is incorrect because HashSet does not order elements based on keys.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 60,
    topic: "Lists, Queues, and Stacks",
  },
  {
    difficulty: 0.9,
    question:
      "Which Java collection class provides a data structure that represents a collection of elements, each associated with a key?",
    answers: ["HashMap", "TreeMap", "LinkedHashMap", "HashSet"],
    correct: 0,
    explanations: [
      "The correct answer is HashMap. HashMap in Java provides a data structure that represents a collection of elements, each associated with a key.",
      "Option TreeMap is incorrect because TreeMap orders elements based on keys.",
      "Option LinkedHashMap is incorrect because LinkedHashMap maintains insertion order but does not specifically associate elements with keys.",
      "Option HashSet is incorrect because HashSet does not associate elements with keys.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 60,
    topic: "Lists, Queues, and Stacks",
  },
];
