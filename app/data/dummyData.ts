export const dummyData: {
  difficulty: number;
  question: string;
  code?: string;
  answers: string[];
  correct: number;
  explanations: string[];
  bloomTaxonomy: string;
  timeTakenSeconds: number;
  topic: string;
}[] = [
  {
    difficulty: 0.3,
    question: "What is recursion?",
    answers: [
      "A programming technique where a function calls itself.",
      "A programming technique where a function calls another function.",
      "A programming technique where a function calls a built-in library function.",
      "A programming technique where a function calls a variable.",
    ],
    correct: 0,
    explanations: [
      "Recursion is a programming technique where a function calls itself.",
      "This is not correct because recursion involves a function calling itself, not another function.",
      "This is not correct because recursion does not necessarily involve built-in library functions.",
      "This is not correct because recursion involves a function calling itself, not a variable.",
    ],
    bloomTaxonomy: "Remembering",
    timeTakenSeconds: 30,
    topic: "Recursion",
  },
  {
    difficulty: 0.4,
    question: "What is the base case in recursion?",
    answers: [
      "The terminating condition that stops the recursive calls.",
      "The first step of the recursive function.",
      "The function that is called recursively.",
      "The variable used inside the recursive function.",
    ],
    correct: 0,
    explanations: [
      "The base case is the terminating condition that stops the recursive calls.",
      "This is not correct because the base case is not the first step but the condition that stops the recursion.",
      "This is not correct because the base case is not a separate function but a condition within the recursive function.",
      "This is not correct because the base case is a condition, not a variable.",
    ],
    bloomTaxonomy: "Remembering",
    timeTakenSeconds: 35,
    topic: "Recursion",
  },
  {
    difficulty: 0.4,
    question: "Which data structure is commonly used to implement recursion?",
    answers: ["Stack", "Queue", "Array", "Linked List"],
    correct: 0,
    explanations: [
      "Stack is commonly used to implement recursion due to its Last In First Out (LIFO) nature.",
      "This is not correct because a queue is not typically used for recursion.",
      "This is not correct because an array is not commonly used for recursion.",
      "This is not correct because a linked list is not commonly used for recursion.",
    ],
    bloomTaxonomy: "Remembering",
    timeTakenSeconds: 40,
    topic: "Recursion",
  },
  {
    difficulty: 0.3,
    question: "What is the main advantage of using recursion?",
    answers: [
      "Simplifies the problem-solving approach.",
      "Requires less memory.",
      "Results in faster execution time.",
      "Avoids the use of loops.",
    ],
    correct: 0,
    explanations: [
      "Recursion simplifies the problem-solving approach by breaking down complex problems into simpler ones.",
      "This is not correct because recursion may sometimes require more memory due to function call overhead.",
      "This is not correct because recursion may sometimes result in slower execution time due to function call overhead.",
      "This is not correct because recursion is a different approach rather than an alternative to loops.",
    ],
    bloomTaxonomy: "Remembering",
    timeTakenSeconds: 35,
    topic: "Recursion",
  },
  {
    difficulty: 0.4,
    question: "What is the typical drawback of using recursion?",
    answers: [
      "May lead to stack overflow for large inputs.",
      "Requires more memory.",
      "Results in slower execution time.",
      "Is difficult to implement.",
    ],
    correct: 0,
    explanations: [
      "One typical drawback of recursion is that it may lead to stack overflow for large inputs.",
      "This is not correct because recursion may sometimes require less memory depending on the implementation.",
      "This is not correct because recursion may sometimes result in faster execution time depending on the problem.",
      "This is not correct because while recursion may be challenging for some, it's not universally difficult to implement.",
    ],
    bloomTaxonomy: "Remembering",
    timeTakenSeconds: 40,
    topic: "Recursion",
  },
  {
    difficulty: 0.5,
    question: "Which of the following is true about recursive functions?",
    answers: [
      "They must have a base case to terminate.",
      "They cannot call themselves.",
      "They always result in an infinite loop.",
      "They cannot return a value.",
    ],
    correct: 0,
    explanations: [
      "Recursive functions must have a base case to terminate, otherwise, they may result in infinite recursion.",
      "This is not correct because recursive functions indeed call themselves.",
      "This is not correct because while recursive functions may result in infinite loops without a base case, it's not always the case.",
      "This is not correct because recursive functions can return values.",
    ],
    bloomTaxonomy: "Remembering",
    timeTakenSeconds: 45,
    topic: "Recursion",
  },
  {
    difficulty: 0.4,
    question: "Which of the following is an example of a recursive function?",
    answers: [
      "Calculating the factorial of a number.",
      "Sorting an array using a loop.",
      "Iterating through a linked list using recursion.",
      "Finding the maximum element in an array using a loop.",
    ],
    correct: 0,
    explanations: [
      "Calculating the factorial of a number is an example of a recursive function as it calls itself with a smaller argument.",
      "This is not correct because sorting an array using a loop is an example of an iterative approach.",
      "This is not correct because iterating through a linked list using recursion is an example of a recursive approach.",
      "This is not correct because finding the maximum element in an array using a loop is an example of an iterative approach.",
    ],
    bloomTaxonomy: "Remembering",
    timeTakenSeconds: 40,
    topic: "Recursion",
  },
  {
    difficulty: 0.1,
    question: "What is the key characteristic of a recursive function?",
    answers: [
      "It calls itself.",
      "It uses a loop.",
      "It has multiple return statements.",
      "It does not have parameters.",
    ],
    correct: 0,
    explanations: [
      "The key characteristic of a recursive function is that it calls itself.",
      "This is not correct because a recursive function doesn't necessarily involve loops.",
      "This is not correct because the presence of multiple return statements is not a defining characteristic of recursion.",
      "This is not correct because recursive functions commonly have parameters.",
    ],
    bloomTaxonomy: "Remembering",
    timeTakenSeconds: 30,
    topic: "Recursion",
  },
  {
    difficulty: 0.15,
    question:
      "Which of the following is essential for a recursive function to terminate?",
    answers: [
      "Base case",
      "Recursive case",
      "Global variables",
      "Function arguments",
    ],
    correct: 0,
    explanations: [
      "A base case is essential for a recursive function to terminate.",
      "This is not correct because while a recursive case is necessary, it's not sufficient for termination.",
      "This is not correct because global variables are not directly related to the termination of recursive functions.",
      "This is not correct because function arguments are used within the recursive calls but are not directly related to termination.",
    ],
    bloomTaxonomy: "Remembering",
    timeTakenSeconds: 35,
    topic: "Recursion",
  },
  {
    difficulty: 0.2,
    question: "What is recursion useful for in programming?",
    answers: [
      "Solving problems with repeated subproblems.",
      "Performing arithmetic operations.",
      "Manipulating strings.",
      "Creating user interfaces.",
    ],
    correct: 0,
    explanations: [
      "Recursion is useful for solving problems with repeated subproblems by breaking them down into smaller instances.",
      "This is not correct because recursion is not limited to arithmetic operations.",
      "This is not correct because recursion is not limited to string manipulation.",
      "This is not correct because recursion is not typically used for creating user interfaces.",
    ],
    bloomTaxonomy: "Remembering",
    timeTakenSeconds: 40,
    topic: "Recursion",
  },
  {
    difficulty: 0.25,
    question: "What does the term 'tail recursion' refer to?",
    answers: [
      "When the recursive call is the last operation in a function.",
      "When the recursive function has multiple base cases.",
      "When the recursive function returns a value.",
      "When the recursive function uses a stack data structure.",
    ],
    correct: 0,
    explanations: [
      "Tail recursion refers to a situation where the recursive call is the last operation in a function.",
      "This is not correct because tail recursion is not about having multiple base cases.",
      "This is not correct because tail recursion is about the position of the recursive call, not about returning a value.",
      "This is not correct because the use of a stack data structure is not specific to tail recursion.",
    ],
    bloomTaxonomy: "Remembering",
    timeTakenSeconds: 45,
    topic: "Recursion",
  },
  {
    difficulty: 0.3,
    question: "Which of the following statements best describes recursion?",
    answers: [
      "A function that calls itself in its definition.",
      "A function that calls another function.",
      "A function that uses a loop to iterate.",
      "A function that returns a value.",
    ],
    correct: 0,
    explanations: [
      "Recursion is best described as a function that calls itself in its definition.",
      "This is not correct because recursion involves a function calling itself, not another function.",
      "This is not correct because recursion doesn't necessarily involve loops.",
      "This is not correct because recursion may or may not return a value.",
    ],
    bloomTaxonomy: "Remembering",
    timeTakenSeconds: 50,
    topic: "Recursion",
  },
  {
    difficulty: 0.35,
    question:
      "What is the primary purpose of a base case in a recursive function?",
    answers: [
      "To stop the recursion.",
      "To initiate the recursion.",
      "To handle edge cases.",
      "To perform arithmetic operations.",
    ],
    correct: 0,
    explanations: [
      "The primary purpose of a base case in a recursive function is to stop the recursion.",
      "This is not correct because the base case doesn't initiate the recursion; it stops it.",
      "This is not correct because while a base case may handle edge cases, its primary purpose is to terminate the recursion.",
      "This is not correct because the base case typically involves comparison or condition checks, not arithmetic operations.",
    ],
    bloomTaxonomy: "Remembering",
    timeTakenSeconds: 55,
    topic: "Recursion",
  },
  {
    difficulty: 0.4,
    question: "What is the risk of infinite recursion in a recursive function?",
    answers: [
      "It can cause a stack overflow error.",
      "It results in a null pointer exception.",
      "It leads to memory leaks.",
      "It causes the program to crash.",
    ],
    correct: 0,
    explanations: [
      "Infinite recursion can cause a stack overflow error as the call stack grows excessively.",
      "This is not correct because infinite recursion does not necessarily result in a null pointer exception.",
      "This is not correct because infinite recursion itself does not lead to memory leaks; it's rather a resource exhaustion issue.",
      "This is not correct because infinite recursion may not always cause an immediate program crash.",
    ],
    bloomTaxonomy: "Remembering",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.1,
    question: "How does recursion differ from iteration in programming?",
    answers: [
      "Recursion uses function calls, while iteration uses loops.",
      "Recursion always requires a base case, while iteration does not.",
      "Recursion is slower than iteration.",
      "Recursion cannot be used for arithmetic operations.",
    ],
    correct: 0,
    explanations: [
      "Recursion differs from iteration in that recursion uses function calls to repeat a set of instructions, while iteration uses loops.",
      "This is not correct because both recursion and iteration can have termination conditions; it's not unique to recursion.",
      "This is not correct because the performance of recursion versus iteration depends on the specific problem and implementation.",
      "This is not correct because recursion can be used for arithmetic operations just like iteration.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 30,
    topic: "Recursion",
  },
  {
    difficulty: 0.15,
    question:
      "What is the concept of 'divide and conquer' related to recursion?",
    answers: [
      "Breaking a problem into smaller, more manageable subproblems.",
      "Combining multiple problems into one.",
      "Using a single base case to handle all scenarios.",
      "Ignoring the base case altogether.",
    ],
    correct: 0,
    explanations: [
      "'Divide and conquer' in recursion involves breaking a problem into smaller, more manageable subproblems.",
      "This is not correct because 'divide and conquer' involves splitting problems, not combining them.",
      "This is not correct because using a single base case for all scenarios is not part of 'divide and conquer'.",
      "This is not correct because ignoring the base case would lead to infinite recursion or incorrect results.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 35,
    topic: "Recursion",
  },
  {
    difficulty: 0.2,
    question: "In a recursive function, what is the role of the call stack?",
    answers: [
      "To keep track of function calls and their local variables.",
      "To store the base case.",
      "To prevent infinite recursion.",
      "To store global variables.",
    ],
    correct: 0,
    explanations: [
      "The call stack in a recursive function keeps track of function calls and their local variables, enabling the function to return to the correct execution point after a recursive call.",
      "This is not correct because the call stack does not store the base case itself; it tracks function calls.",
      "This is not correct because the call stack itself does not prevent infinite recursion; it's the base case that does.",
      "This is not correct because the call stack primarily deals with function calls and local variables, not global variables.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 40,
    topic: "Recursion",
  },
  {
    difficulty: 0.25,
    question:
      "What is the significance of the stack in recursive function calls?",
    answers: [
      "It manages the sequence of function calls and their local variables.",
      "It stores the base case.",
      "It ensures the recursive function returns null.",
      "It handles exceptions thrown by the recursive function.",
    ],
    correct: 0,
    explanations: [
      "The stack in recursive function calls manages the sequence of function calls and their local variables, allowing proper execution and return.",
      "This is not correct because the stack does not store the base case; it's the structure that facilitates function call sequencing.",
      "This is not correct because the stack's purpose is not related to ensuring the function returns null.",
      "This is not correct because the stack's primary role is not handling exceptions but managing function calls and local variables.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 45,
    topic: "Recursion",
  },
  {
    difficulty: 0.3,
    question:
      "Why is it essential to have a base case in a recursive function?",
    answers: [
      "To provide a termination condition for the recursion.",
      "To handle exceptions thrown by the recursive calls.",
      "To initialize the function parameters.",
      "To ensure the function always returns a value.",
    ],
    correct: 0,
    explanations: [
      "Having a base case in a recursive function is essential to provide a termination condition, preventing infinite recursion.",
      "This is not correct because while exceptions should be handled, the base case is specifically for termination conditions.",
      "This is not correct because the base case is not about initializing parameters but providing a termination condition.",
      "This is not correct because the base case ensures termination; it's not directly related to the return value.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 50,
    topic: "Recursion",
  },
  {
    difficulty: 0.35,
    question: "How does recursion help in solving problems more elegantly?",
    answers: [
      "By breaking down complex problems into simpler subproblems.",
      "By using fewer function calls.",
      "By avoiding the use of loops entirely.",
      "By reducing the need for base cases.",
    ],
    correct: 0,
    explanations: [
      "Recursion helps in solving problems more elegantly by breaking down complex problems into simpler subproblems, which can then be solved individually.",
      "This is not correct because the elegance of recursion comes from its ability to break down problems, not from the number of function calls.",
      "This is not correct because recursion can coexist with loops and sometimes may even be implemented using loops.",
      "This is not correct because the presence of base cases is crucial for recursion to work correctly; it doesn't reduce the need for them.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 55,
    topic: "Recursion",
  },
  {
    difficulty: 0.1,
    question: "Which of the following best describes the process of recursion?",
    answers: [
      "A function calls itself until a base condition is met.",
      "A function calls another function.",
      "A function iterates over a collection using a loop.",
      "A function performs arithmetic operations.",
    ],
    correct: 0,
    explanations: [
      "Recursion involves a function calling itself until a base condition is met.",
      "This is not correct because recursion involves a function calling itself, not another function.",
      "This is not correct because recursion is distinct from iteration.",
      "This is not correct because recursion is not limited to arithmetic operations.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 30,
    topic: "Recursion",
  },
  {
    difficulty: 0.15,
    question:
      "What is the primary purpose of a base case in a recursive function?",
    answers: [
      "To provide a termination condition for recursion.",
      "To initialize variables.",
      "To call other functions.",
      "To handle exceptions.",
    ],
    correct: 0,
    explanations: [
      "The base case in a recursive function provides a termination condition for recursion.",
      "This is not correct because the base case is not primarily for variable initialization.",
      "This is not correct because the base case is not meant for calling other functions.",
      "This is not correct because the base case is not primarily for handling exceptions.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 35,
    topic: "Recursion",
  },
  {
    difficulty: 0.2,
    question:
      "Which data structure is typically used to manage recursive function calls?",
    answers: ["Call stack", "Queue", "Linked list", "Array"],
    correct: 0,
    explanations: [
      "The call stack is typically used to manage recursive function calls.",
      "This is not correct because a queue is not typically used for managing recursive calls.",
      "This is not correct because a linked list is not typically used for managing recursive calls.",
      "This is not correct because an array is not typically used for managing recursive calls.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 40,
    topic: "Recursion",
  },
  {
    difficulty: 0.25,
    question: "What is a potential downside of using recursion in programming?",
    answers: [
      "Risk of stack overflow for large inputs.",
      "Increased performance.",
      "Simplified code structure.",
      "Better memory management.",
    ],
    correct: 0,
    explanations: [
      "A potential downside of using recursion is the risk of stack overflow for large inputs due to excessive function calls.",
      "This is not correct because recursion may sometimes result in decreased performance.",
      "This is not correct because recursion may not always result in a simplified code structure.",
      "This is not correct because recursion may not always lead to better memory management.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 45,
    topic: "Recursion",
  },
  {
    difficulty: 0.3,
    question: "Which of the following is true about tail recursion?",
    answers: [
      "The recursive call is the last operation in the function.",
      "The recursive call is the first operation in the function.",
      "Tail recursion always leads to stack overflow.",
      "Tail recursion requires multiple base cases.",
    ],
    correct: 0,
    explanations: [
      "In tail recursion, the recursive call is the last operation in the function.",
      "This is not correct because tail recursion involves the recursive call being the last operation, not the first.",
      "This is not correct because tail recursion does not always lead to stack overflow.",
      "This is not correct because tail recursion doesn't necessarily require multiple base cases.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 50,
    topic: "Recursion",
  },
  {
    difficulty: 0.35,
    question:
      "How does recursion help in solving problems with repeated subproblems?",
    answers: [
      "By breaking down the problem into smaller instances.",
      "By executing loops iteratively.",
      "By using global variables.",
      "By ignoring the base case.",
    ],
    correct: 0,
    explanations: [
      "Recursion helps in solving problems with repeated subproblems by breaking down the problem into smaller instances.",
      "This is not correct because recursion is distinct from iterative looping constructs.",
      "This is not correct because recursion typically avoids the use of global variables.",
      "This is not correct because ignoring the base case would lead to incorrect results or infinite recursion.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 55,
    topic: "Recursion",
  },
  {
    difficulty: 0.4,
    question:
      "What is the potential consequence of a recursive function lacking a base case?",
    answers: [
      "It may result in infinite recursion.",
      "It always throws an exception.",
      "It automatically returns null.",
      "It leads to a stack overflow error.",
    ],
    correct: 0,
    explanations: [
      "If a recursive function lacks a base case, it may result in infinite recursion, where the function calls itself indefinitely without termination.",
      "This is not correct because the absence of a base case doesn't always result in an immediate exception.",
      "This is not correct because the absence of a base case does not automatically imply a null return.",
      "This is not correct because while infinite recursion is a risk, the immediate consequence is not necessarily a stack overflow error.",
    ],
    bloomTaxonomy: "Understanding",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.1,
    question:
      "Write a recursive function in Java to calculate the factorial of a non-negative integer.",
    code: "public class Factorial {\n    public int calculateFactorial(int n) {\n        if (n == 0)\n            return 1;\n        else\n            return n * calculateFactorial(n - 1);\n    }\n}",
    answers: [
      "The given code correctly implements a recursive function to calculate the factorial of a non-negative integer.",
      "The given code contains syntax errors.",
      "The given code implements an iterative solution.",
      "The given code does not calculate the factorial.",
    ],
    correct: 0,
    explanations: [
      "The given code correctly implements a recursive function to calculate the factorial of a non-negative integer by calling itself with a smaller argument.",
      "This is not correct because the given code is syntactically correct.",
      "This is not correct because the given code implements a recursive solution, not an iterative one.",
      "This is not correct because the given code does indeed calculate the factorial.",
    ],
    bloomTaxonomy: "Applying",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.15,
    question:
      "Implement a recursive function in Java to compute the nth Fibonacci number.",
    code: "public class Fibonacci {\n    public int calculateFibonacci(int n) {\n        if (n <= 1)\n            return n;\n        else\n            return calculateFibonacci(n - 1) + calculateFibonacci(n - 2);\n    }\n}",
    answers: [
      "The given code correctly implements a recursive function to compute the nth Fibonacci number.",
      "The given code contains logic errors.",
      "The given code implements an iterative solution.",
      "The given code does not compute the Fibonacci sequence.",
    ],
    correct: 0,
    explanations: [
      "The given code correctly implements a recursive function to compute the nth Fibonacci number by calling itself recursively with smaller arguments.",
      "This is not correct because the given code is logically correct.",
      "This is not correct because the given code implements a recursive solution, not an iterative one.",
      "This is not correct because the given code indeed computes the Fibonacci sequence.",
    ],
    bloomTaxonomy: "Applying",
    timeTakenSeconds: 70,
    topic: "Recursion",
  },
  {
    difficulty: 0.2,
    question:
      "Write a Java method that recursively calculates the sum of all elements in an integer array.",
    code: "public class ArraySum {\n    public int calculateSum(int[] arr, int index) {\n        if (index < 0)\n            return 0;\n        else\n            return arr[index] + calculateSum(arr, index - 1);\n    }\n}",
    answers: [
      "The given code correctly implements a recursive method to calculate the sum of all elements in an integer array.",
      "The given code contains compilation errors.",
      "The given code implements an iterative solution.",
      "The given code does not calculate the sum of array elements.",
    ],
    correct: 0,
    explanations: [
      "The given code correctly implements a recursive method to calculate the sum of all elements in an integer array by calling itself with a decreasing index.",
      "This is not correct because the given code is free of compilation errors.",
      "This is not correct because the given code implements a recursive solution, not an iterative one.",
      "This is not correct because the given code indeed calculates the sum of array elements.",
    ],
    bloomTaxonomy: "Applying",
    timeTakenSeconds: 80,
    topic: "Recursion",
  },
  {
    difficulty: 0.25,
    question: "Implement a recursive function in Java to reverse a string.",
    code: "public class StringReverse {\n    public String reverseString(String str) {\n        if (str.isEmpty())\n            return str;\n        else\n            return reverseString(str.substring(1)) + str.charAt(0);\n    }\n}",
    answers: [
      "The given code correctly implements a recursive function to reverse a string.",
      "The given code has logical flaws.",
      "The given code implements an iterative solution.",
      "The given code does not reverse the string.",
    ],
    correct: 0,
    explanations: [
      "The given code correctly implements a recursive function to reverse a string by calling itself recursively with a substring.",
      "This is not correct because the given code is logically sound.",
      "This is not correct because the given code implements a recursive solution, not an iterative one.",
      "This is not correct because the given code indeed reverses the string.",
    ],
    bloomTaxonomy: "Applying",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.3,
    question:
      "Write a recursive Java method to find the maximum element in an integer array.",
    code: "public class MaxElement {\n    public int findMax(int[] arr, int index) {\n        if (index == arr.length - 1)\n            return arr[index];\n        else\n            return Math.max(arr[index], findMax(arr, index + 1));\n    }\n}",
    answers: [
      "The given code correctly implements a recursive method to find the maximum element in an integer array.",
      "The given code contains syntax errors.",
      "The given code implements an iterative solution.",
      "The given code does not find the maximum element.",
    ],
    correct: 0,
    explanations: [
      "The given code correctly implements a recursive method to find the maximum element in an integer array by calling itself recursively with an incremented index.",
      "This is not correct because the given code is syntactically correct.",
      "This is not correct because the given code implements a recursive solution, not an iterative one.",
      "This is not correct because the given code indeed finds the maximum element in the array.",
    ],
    bloomTaxonomy: "Applying",
    timeTakenSeconds: 100,
    topic: "Recursion",
  },
  {
    difficulty: 0.1,
    question:
      "Write a recursive Java function to calculate the power of a number.",
    code: "public class Power {\n    public int calculatePower(int base, int exponent) {\n        if (exponent == 0)\n            return 1;\n        else\n            return base * calculatePower(base, exponent - 1);\n    }\n}",
    answers: [
      "The given code correctly implements a recursive function to calculate the power of a number.",
      "The given code contains syntax errors.",
      "The given code implements an iterative solution.",
      "The given code does not calculate the power.",
    ],
    correct: 0,
    explanations: [
      "The given code correctly implements a recursive function to calculate the power of a number by repeatedly multiplying the base.",
      "This is not correct because the given code is syntactically correct.",
      "This is not correct because the given code implements a recursive solution, not an iterative one.",
      "This is not correct because the given code indeed calculates the power.",
    ],
    bloomTaxonomy: "Applying",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.15,
    question:
      "Implement a recursive Java method to check if a given number is prime.",
    code: "public class PrimeChecker {\n    public boolean isPrime(int num, int divisor) {\n        if (divisor <= 1)\n            return true;\n        else if (num % divisor == 0)\n            return false;\n        else\n            return isPrime(num, divisor - 1);\n    }\n}",
    answers: [
      "The given code correctly implements a recursive method to check if a given number is prime.",
      "The given code has logical errors.",
      "The given code implements an iterative solution.",
      "The given code does not check for prime numbers.",
    ],
    correct: 0,
    explanations: [
      "The given code correctly implements a recursive method to check if a given number is prime by recursively checking divisibility.",
      "This is not correct because the given code is logically sound.",
      "This is not correct because the given code implements a recursive solution, not an iterative one.",
      "This is not correct because the given code indeed checks for prime numbers.",
    ],
    bloomTaxonomy: "Applying",
    timeTakenSeconds: 70,
    topic: "Recursion",
  },
  {
    difficulty: 0.2,
    question:
      "Write a Java method that recursively calculates the nth term of the Fibonacci sequence.",
    code: "public class Fibonacci {\n    public int calculateFibonacci(int n) {\n        if (n <= 1)\n            return n;\n        else\n            return calculateFibonacci(n - 1) + calculateFibonacci(n - 2);\n    }\n}",
    answers: [
      "The given code correctly implements a recursive method to calculate the nth term of the Fibonacci sequence.",
      "The given code contains compilation errors.",
      "The given code implements an iterative solution.",
      "The given code does not calculate the Fibonacci sequence.",
    ],
    correct: 0,
    explanations: [
      "The given code correctly implements a recursive method to calculate the nth term of the Fibonacci sequence by calling itself with smaller arguments.",
      "This is not correct because the given code is free of compilation errors.",
      "This is not correct because the given code implements a recursive solution, not an iterative one.",
      "This is not correct because the given code indeed calculates the Fibonacci sequence.",
    ],
    bloomTaxonomy: "Applying",
    timeTakenSeconds: 80,
    topic: "Recursion",
  },
  {
    difficulty: 0.25,
    question:
      "Implement a recursive Java function to find the GCD (Greatest Common Divisor) of two integers.",
    code: "public class GCD {\n    public int findGCD(int a, int b) {\n        if (b == 0)\n            return a;\n        else\n            return findGCD(b, a % b);\n    }\n}",
    answers: [
      "The given code correctly implements a recursive function to find the GCD of two integers.",
      "The given code contains syntax errors.",
      "The given code implements an iterative solution.",
      "The given code does not find the GCD.",
    ],
    correct: 0,
    explanations: [
      "The given code correctly implements a recursive function to find the GCD of two integers using Euclid's algorithm.",
      "This is not correct because the given code is syntactically correct.",
      "This is not correct because the given code implements a recursive solution, not an iterative one.",
      "This is not correct because the given code indeed finds the GCD.",
    ],
    bloomTaxonomy: "Applying",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.3,
    question:
      "Write a recursive Java method to generate all permutations of a given string.",
    code: "public class Permutations {\n    public void generatePermutations(String prefix, String str) {\n        int n = str.length();\n        if (n == 0)\n            System.out.println(prefix);\n        else {\n            for (int i = 0; i < n; i++)\n                generatePermutations(prefix + str.charAt(i), str.substring(0, i) + str.substring(i + 1, n));\n        }\n    }\n}",
    answers: [
      "The given code correctly implements a recursive method to generate all permutations of a given string.",
      "The given code has logical flaws.",
      "The given code implements an iterative solution.",
      "The given code does not generate permutations.",
    ],
    correct: 0,
    explanations: [
      "The given code correctly implements a recursive method to generate all permutations of a given string by generating permutations recursively.",
      "This is not correct because the given code is logically sound.",
      "This is not correct because the given code implements a recursive solution, not an iterative one.",
      "This is not correct because the given code indeed generates permutations.",
    ],
    bloomTaxonomy: "Applying",
    timeTakenSeconds: 100,
    topic: "Recursion",
  },
  {
    difficulty: 0.1,
    question:
      "Write a recursive Java function to calculate the sum of digits of a positive integer.",
    code: "public class DigitSum {\n    public int calculateDigitSum(int n) {\n        if (n < 10)\n            return n;\n        else\n            return n % 10 + calculateDigitSum(n / 10);\n    }\n}",
    answers: [
      "The given code correctly implements a recursive function to calculate the sum of digits of a positive integer.",
      "The given code contains syntax errors.",
      "The given code implements an iterative solution.",
      "The given code does not calculate the sum of digits.",
    ],
    correct: 0,
    explanations: [
      "The given code correctly implements a recursive function to calculate the sum of digits of a positive integer by recursively adding the last digit.",
      "This is not correct because the given code is syntactically correct.",
      "This is not correct because the given code implements a recursive solution, not an iterative one.",
      "This is not correct because the given code indeed calculates the sum of digits.",
    ],
    bloomTaxonomy: "Applying",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.15,
    question:
      "Implement a recursive Java function to calculate the number of trailing zeroes in the factorial of a positive integer.",
    code: "public class TrailingZeroes {\n    public int countTrailingZeroes(int n) {\n        if (n < 5)\n            return 0;\n        else\n            return n / 5 + countTrailingZeroes(n / 5);\n    }\n}",
    answers: [
      "The given code correctly implements a recursive function to calculate the number of trailing zeroes in the factorial of a positive integer.",
      "The given code has logical errors.",
      "The given code implements an iterative solution.",
      "The given code does not calculate trailing zeroes.",
    ],
    correct: 0,
    explanations: [
      "The given code correctly implements a recursive function to calculate the number of trailing zeroes in the factorial of a positive integer using the concept of prime factorization.",
      "This is not correct because the given code is logically sound.",
      "This is not correct because the given code implements a recursive solution, not an iterative one.",
      "This is not correct because the given code indeed calculates trailing zeroes.",
    ],
    bloomTaxonomy: "Applying",
    timeTakenSeconds: 70,
    topic: "Recursion",
  },
  {
    difficulty: 0.2,
    question:
      "Write a recursive Java method to find the nth term of the arithmetic sequence.",
    code: "public class ArithmeticSequence {\n    public int calculateNthTerm(int firstTerm, int difference, int n) {\n        if (n == 1)\n            return firstTerm;\n        else\n            return calculateNthTerm(firstTerm + difference, difference, n - 1);\n    }\n}",
    answers: [
      "The given code correctly implements a recursive method to find the nth term of the arithmetic sequence.",
      "The given code contains compilation errors.",
      "The given code implements an iterative solution.",
      "The given code does not find the nth term.",
    ],
    correct: 0,
    explanations: [
      "The given code correctly implements a recursive method to find the nth term of the arithmetic sequence by recursively adding the common difference.",
      "This is not correct because the given code is free of compilation errors.",
      "This is not correct because the given code implements a recursive solution, not an iterative one.",
      "This is not correct because the given code indeed finds the nth term.",
    ],
    bloomTaxonomy: "Applying",
    timeTakenSeconds: 80,
    topic: "Recursion",
  },
  {
    difficulty: 0.25,
    question:
      "Implement a recursive Java function to check if a given string is a palindrome.",
    code: "public class PalindromeChecker {\n    public boolean isPalindrome(String str) {\n        if (str.length() <= 1)\n            return true;\n        else if (str.charAt(0) != str.charAt(str.length() - 1))\n            return false;\n        else\n            return isPalindrome(str.substring(1, str.length() - 1));\n    }\n}",
    answers: [
      "The given code correctly implements a recursive function to check if a given string is a palindrome.",
      "The given code contains syntax errors.",
      "The given code implements an iterative solution.",
      "The given code does not check for palindromes.",
    ],
    correct: 0,
    explanations: [
      "The given code correctly implements a recursive function to check if a given string is a palindrome by comparing characters from both ends.",
      "This is not correct because the given code is syntactically correct.",
      "This is not correct because the given code implements a recursive solution, not an iterative one.",
      "This is not correct because the given code indeed checks for palindromes.",
    ],
    bloomTaxonomy: "Applying",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.1,
    question:
      'Consider the following recursive function in Java. What will be the output when calling mystery(3)?\n\n```java\npublic class Mystery {\n    public static void mystery(int n) {\n        if (n > 0) {\n            mystery(n - 1);\n            System.out.print(n + " ");\n        }\n    }\n\n    public static void main(String[] args) {\n        mystery(3);\n    }\n}\n```',
    code: 'public class Mystery {\n    public static void mystery(int n) {\n        if (n > 0) {\n            mystery(n - 1);\n            System.out.print(n + " ");\n        }\n    }\n\n    public static void main(String[] args) {\n        mystery(3);\n    }\n}',
    answers: [
      "The output will be '1 2 3'.",
      "The output will be '3 2 1'.",
      "The output will be '3 2 1 1 2 3'.",
      "The output will be '1 1 2 1 2 3'.",
    ],
    correct: 0,
    explanations: [
      "The function mystery(n) recursively calls itself with n - 1 until n becomes 0. Then, it prints the value of n when returning from the recursive calls. So, when calling mystery(3), it prints '1 2 3'.",
      "This is incorrect because the function prints the value of n after the recursive call, resulting in '1 2 3'.",
      "This is incorrect because it includes the intermediate outputs of recursive calls, resulting in '1 2 3'.",
      "This is incorrect because it includes extra repetitions of '1' and misses '3', resulting in '1 1 2 1 2 3'.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.15,
    question:
      "What will be the time complexity of the following recursive function in terms of Big O notation?\n\n```java\npublic int recursiveFunction(int n) {\n    if (n <= 1)\n        return n;\n    else\n        return recursiveFunction(n - 1) + recursiveFunction(n - 2);\n}\n```",
    answers: ["O(2^n)", "O(n)", "O(log n)", "O(n^2)"],
    correct: 0,
    explanations: [
      "The given recursive function is the Fibonacci sequence algorithm using recursion. Its time complexity is exponential, O(2^n), because each function call results in two more calls.",
      "This is incorrect because the time complexity is not linear; it's exponential.",
      "This is incorrect because the time complexity is not logarithmic; it's exponential.",
      "This is incorrect because the time complexity is not quadratic; it's exponential.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.2,
    question:
      "Consider the following recursive function in Java. What will be the value of x after calling mystery(5)?\n\n```java\nint mystery(int n) {\n    if (n == 0)\n        return 0;\n    else\n        return n + mystery(n - 1);\n}\n```",
    code: "int mystery(int n) {\n    if (n == 0)\n        return 0;\n    else\n        return n + mystery(n - 1);\n}",
    answers: [
      "The value of x will be 15.",
      "The value of x will be 5.",
      "The value of x will be 10.",
      "The value of x will be 20.",
    ],
    correct: 0,
    explanations: [
      "The function calculates the sum of integers from 1 to n recursively. So, the value of x after calling mystery(5) will be 15.",
      "This is incorrect because the function calculates the sum of integers from 1 to n, not just n itself.",
      "This is incorrect because the value of x is the sum of integers from 1 to 5, which is 15.",
      "This is incorrect because the value of x is not doubled; it's the sum of integers from 1 to 5, which is 15.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.25,
    question:
      'What will be the output of the following Java code?\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(mystery("hello", 0));\n    }\n    \n    public static String mystery(String s, int index) {\n        if (index == s.length())\n            return "";\n        else\n            return mystery(s, index + 1) + s.charAt(index);\n    }\n}\n```',
    code: 'public class Main {\n    public static void main(String[] args) {\n        System.out.println(mystery("hello", 0));\n    }\n    \n    public static String mystery(String s, int index) {\n        if (index == s.length())\n            return "";\n        else\n            return mystery(s, index + 1) + s.charAt(index);\n    }\n}',
    answers: [
      "The output will be 'olleh'.",
      "The output will be 'hello'.",
      "The output will be 'eh'.",
      "The output will be 'lo'.",
    ],
    correct: 0,
    explanations: [
      "The function 'mystery' recursively reverses the string 's'. So, the output will be 'olleh'.",
      "This is incorrect because the function recursively reverses the string 's'.",
      "This is incorrect because the function recursively reverses the entire string 's'.",
      "This is incorrect because the function recursively reverses the entire string 's'.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.1,
    question:
      "Consider the following recursive function in Java. What will be the output when calling mystery(4)?\n\n```java\npublic int mystery(int n) {\n    if (n <= 0)\n        return 1;\n    else\n        return n * mystery(n - 1);\n}\n```",
    code: "public int mystery(int n) {\n    if (n <= 0)\n        return 1;\n    else\n        return n * mystery(n - 1);\n}",
    answers: [
      "The output will be 24.",
      "The output will be 120.",
      "The output will be 720.",
      "The output will be 5040.",
    ],
    correct: 1,
    explanations: [
      "The function calculates the factorial of a given number. So, calling mystery(4) will result in 4 * 3 * 2 * 1 = 24.",
      "This is incorrect because the function calculates the factorial of the input.",
      "This is incorrect because the function calculates the factorial of the input.",
      "This is incorrect because the function calculates the factorial of the input.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.15,
    question:
      "What is the time complexity of the following recursive function in terms of Big O notation?\n\n```java\npublic int recursiveFunc(int n) {\n    if (n <= 1)\n        return n;\n    else\n        return recursiveFunc(n - 1) + recursiveFunc(n - 2);\n}\n```",
    code: "public int recursiveFunc(int n) {\n    if (n <= 1)\n        return n;\n    else\n        return recursiveFunc(n - 1) + recursiveFunc(n - 2);\n}",
    answers: ["O(2^n)", "O(n)", "O(log n)", "O(n^2)"],
    correct: 0,
    explanations: [
      "The function implements the Fibonacci sequence using recursion, resulting in exponential time complexity O(2^n).",
      "This is incorrect because the time complexity of the function is not linear.",
      "This is incorrect because the time complexity of the function is not logarithmic.",
      "This is incorrect because the time complexity of the function is not quadratic.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.2,
    question:
      "Consider the recursive function below. What will be the output when calling mystery(5)?\n\n```java\npublic int mystery(int n) {\n    if (n <= 0)\n        return 0;\n    else\n        return n + mystery(n - 2);\n}\n```",
    code: "public int mystery(int n) {\n    if (n <= 0)\n        return 0;\n    else\n        return n + mystery(n - 2);\n}",
    answers: [
      "The output will be 9.",
      "The output will be 10.",
      "The output will be 11.",
      "The output will be 12.",
    ],
    correct: 2,
    explanations: [
      "The function calculates the sum of all odd numbers up to the given input. So, calling mystery(5) will result in 1 + 3 + 5 = 9.",
      "This is incorrect because the function calculates the sum of all odd numbers up to the given input.",
      "This is the correct answer because calling mystery(5) will result in 1 + 3 + 5 = 9.",
      "This is incorrect because the function calculates the sum of all odd numbers up to the given input.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.25,
    question:
      "What will be the output of the following recursive function in Java when calling mystery(3)?\n\n```java\npublic int mystery(int n) {\n    if (n <= 0)\n        return 0;\n    else\n        return n * mystery(n - 3);\n}\n```",
    code: "public int mystery(int n) {\n    if (n <= 0)\n        return 0;\n    else\n        return n * mystery(n - 3);\n}",
    answers: [
      "The output will be 0.",
      "The output will be 6.",
      "The output will be 18.",
      "The output will be 27.",
    ],
    correct: 0,
    explanations: [
      "The function returns 0 for n <= 0. So, calling mystery(3) will result in 0.",
      "This is incorrect because the function returns 0 for n <= 0.",
      "This is incorrect because the function returns 0 for n <= 0.",
      "This is incorrect because the function returns 0 for n <= 0.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.3,
    question:
      "Consider the following recursive function in Java. What will be the output when calling mystery(4)?\n\n```java\npublic int mystery(int n) {\n    if (n == 0)\n        return 1;\n    else\n        return mystery(n / 2);\n}\n```",
    code: "public int mystery(int n) {\n    if (n == 0)\n        return 1;\n    else\n        return mystery(n / 2);\n}",
    answers: [
      "The output will be 1.",
      "The output will be 2.",
      "The output will be 3.",
      "The output will be 4.",
    ],
    correct: 0,
    explanations: [
      "The function recursively calls itself with n / 2 until n becomes 0. So, calling mystery(4) will result in 1.",
      "This is incorrect because the function returns 1 when n == 0.",
      "This is incorrect because the function returns 1 when n == 0.",
      "This is incorrect because the function returns 1 when n == 0.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.1,
    question:
      "Consider the following recursive function in Java. What will be the output when calling mystery(3)?\n\n```java\npublic int mystery(int n) {\n    if (n <= 0)\n        return 0;\n    else\n        return n + mystery(n - 1);\n}\n```",
    code: "public int mystery(int n) {\n    if (n <= 0)\n        return 0;\n    else\n        return n + mystery(n - 1);\n}",
    answers: [
      "The output will be 6.",
      "The output will be 3.",
      "The output will be 0.",
      "The output will be 15.",
    ],
    correct: 0,
    explanations: [
      "The function calculates the sum of integers from 1 to n. So, calling mystery(3) will result in 6.",
      "This is incorrect because the function calculates the sum of integers from 1 to n.",
      "This is incorrect because the function calculates the sum of integers from 1 to n.",
      "This is incorrect because the function calculates the sum of integers from 1 to n.",
    ],
    bloomTaxonomy: "Evaluating",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.15,
    question:
      "What is the time complexity of the following recursive function in terms of Big O notation?\n\n```java\npublic int recursiveFunc(int n) {\n    if (n <= 1)\n        return n;\n    else\n        return recursiveFunc(n - 1) + recursiveFunc(n - 2);\n}\n```",
    code: "public int recursiveFunc(int n) {\n    if (n <= 1)\n        return n;\n    else\n        return recursiveFunc(n - 1) + recursiveFunc(n - 2);\n}",
    answers: ["O(2^n)", "O(n)", "O(log n)", "O(n^2)"],
    correct: 0,
    explanations: [
      "The function implements the Fibonacci sequence using recursion, resulting in exponential time complexity O(2^n).",
      "This is incorrect because the time complexity of the function is not linear.",
      "This is incorrect because the time complexity of the function is not logarithmic.",
      "This is incorrect because the time complexity of the function is not quadratic.",
    ],
    bloomTaxonomy: "Evaluating",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.2,
    question:
      "Consider the recursive function below. What will be the output when calling mystery(4)?\n\n```java\npublic int mystery(int n) {\n    if (n <= 0)\n        return 1;\n    else\n        return n * mystery(n - 1);\n}\n```",
    code: "public int mystery(int n) {\n    if (n <= 0)\n        return 1;\n    else\n        return n * mystery(n - 1);\n}",
    answers: [
      "The output will be 24.",
      "The output will be 10.",
      "The output will be 0.",
      "The output will be 1.",
    ],
    correct: 0,
    explanations: [
      "The function calculates the factorial of a given number. So, calling mystery(4) will result in 24.",
      "This is incorrect because the function calculates the factorial of a given number.",
      "This is incorrect because the function calculates the factorial of a given number.",
      "This is incorrect because the function calculates the factorial of a given number.",
    ],
    bloomTaxonomy: "Evaluating",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.25,
    question:
      "What will be the output of the following recursive function in Java when calling mystery(5)?\n\n```java\npublic int mystery(int n) {\n    if (n <= 0)\n        return 1;\n    else\n        return n * mystery(n - 2);\n}\n```",
    code: "public int mystery(int n) {\n    if (n <= 0)\n        return 1;\n    else\n        return n * mystery(n - 2);\n}",
    answers: [
      "The output will be 15.",
      "The output will be 120.",
      "The output will be 0.",
      "The output will be 1.",
    ],
    correct: 0,
    explanations: [
      "The function calculates the factorial of odd numbers. So, calling mystery(5) will result in 15.",
      "This is incorrect because the function calculates the factorial of odd numbers.",
      "This is incorrect because the function calculates the factorial of odd numbers.",
      "This is incorrect because the function calculates the factorial of odd numbers.",
    ],
    bloomTaxonomy: "Evaluating",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.3,
    question:
      "Consider the following recursive function in Java. What will be the output when calling mystery(4)?\n\n```java\npublic int mystery(int n) {\n    if (n == 0)\n        return 1;\n    else\n        return mystery(n / 2);\n}\n```",
    code: "public int mystery(int n) {\n    if (n == 0)\n        return 1;\n    else\n        return mystery(n / 2);\n}",
    answers: [
      "The output will be 1.",
      "The output will be 2.",
      "The output will be 3.",
      "The output will be 4.",
    ],
    correct: 0,
    explanations: [
      "The function recursively calls itself with n / 2 until n becomes 0. So, calling mystery(4) will result in 1.",
      "This is incorrect because the function returns 1 when n == 0.",
      "This is incorrect because the function returns 1 when n == 0.",
      "This is incorrect because the function returns 1 when n == 0.",
    ],
    bloomTaxonomy: "Evaluating",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.05,
    question:
      "Write a recursive function in Java to calculate the factorial of a given number.",
    code: "public int factorial(int n) {\n    if (n == 0)\n        return 1;\n    else\n        return n * factorial(n - 1);\n}",
    answers: [
      "The provided code is a correct implementation of the factorial function.",
      "The provided code contains syntax errors.",
      "The provided code does not handle negative numbers.",
      "The provided code will result in a stack overflow for large inputs.",
    ],
    correct: 0,
    explanations: [
      "The provided code correctly implements the factorial function using recursion.",
      "This is incorrect because the provided code is syntactically correct.",
      "This is incorrect because the provided code handles 0 correctly.",
      "This is incorrect because the provided code is tail-recursive and won't result in a stack overflow for large inputs.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.1,
    question:
      "Implement a recursive function in Java to calculate the nth Fibonacci number.",
    code: "public int fibonacci(int n) {\n    if (n <= 1)\n        return n;\n    else\n        return fibonacci(n - 1) + fibonacci(n - 2);\n}",
    answers: [
      "The provided code is a correct implementation of the Fibonacci function.",
      "The provided code contains logical errors.",
      "The provided code does not handle negative numbers.",
      "The provided code will result in a stack overflow for large inputs.",
    ],
    correct: 0,
    explanations: [
      "The provided code correctly implements the Fibonacci function using recursion.",
      "This is incorrect because the provided code is logically correct.",
      "This is incorrect because the provided code handles base cases correctly.",
      "This is incorrect because the provided code is tail-recursive and won't result in a stack overflow for large inputs.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.15,
    question:
      "Create a recursive function in Java to find the sum of digits of a given number.",
    code: "public int digitSum(int n) {\n    if (n == 0)\n        return 0;\n    else\n        return n % 10 + digitSum(n / 10);\n}",
    answers: [
      "The provided code is a correct implementation to find the sum of digits of a number.",
      "The provided code contains syntax errors.",
      "The provided code does not handle negative numbers.",
      "The provided code will result in a stack overflow for large inputs.",
    ],
    correct: 0,
    explanations: [
      "The provided code correctly implements the sum of digits function using recursion.",
      "This is incorrect because the provided code is syntactically correct.",
      "This is incorrect because the provided code handles 0 correctly.",
      "This is incorrect because the provided code is tail-recursive and won't result in a stack overflow for large inputs.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.2,
    question:
      "Write a recursive function in Java to calculate the sum of all even numbers up to a given limit.",
    code: "public int evenSum(int n) {\n    if (n <= 0)\n        return 0;\n    else\n        return (n % 2 == 0 ? n : 0) + evenSum(n - 1);\n}",
    answers: [
      "The provided code is a correct implementation to calculate the sum of even numbers.",
      "The provided code contains logical errors.",
      "The provided code does not handle negative numbers.",
      "The provided code will result in a stack overflow for large inputs.",
    ],
    correct: 0,
    explanations: [
      "The provided code correctly implements the sum of even numbers function using recursion.",
      "This is incorrect because the provided code is logically correct.",
      "This is incorrect because the provided code handles 0 correctly.",
      "This is incorrect because the provided code is tail-recursive and won't result in a stack overflow for large inputs.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.1,
    question:
      "Write a recursive function in Java to check if a given string is a palindrome.",
    code: "public boolean isPalindrome(String s) {\n    if (s.length() <= 1)\n        return true;\n    else\n        return s.charAt(0) == s.charAt(s.length() - 1) && isPalindrome(s.substring(1, s.length() - 1));\n}",
    answers: [
      "The provided code correctly checks if the string is a palindrome.",
      "The provided code contains logical errors.",
      "The provided code does not handle empty strings.",
      "The provided code will result in a stack overflow for large inputs.",
    ],
    correct: 0,
    explanations: [
      "The provided code correctly implements the palindrome checking function using recursion.",
      "This is incorrect because the provided code is logically correct.",
      "This is incorrect because the provided code handles single character and empty strings correctly.",
      "This is incorrect because the provided code is tail-recursive and won't result in a stack overflow for large inputs.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.15,
    question:
      "Implement a recursive function in Java to compute the exponentiation of a number.",
    code: "public int power(int base, int exponent) {\n    if (exponent == 0)\n        return 1;\n    else\n        return base * power(base, exponent - 1);\n}",
    answers: [
      "The provided code correctly computes the exponentiation.",
      "The provided code contains logical errors.",
      "The provided code does not handle negative exponents.",
      "The provided code will result in a stack overflow for large inputs.",
    ],
    correct: 0,
    explanations: [
      "The provided code correctly implements the exponentiation function using recursion.",
      "This is incorrect because the provided code is logically correct.",
      "This is incorrect because the provided code handles 0 exponent correctly.",
      "This is incorrect because the provided code is tail-recursive and won't result in a stack overflow for large inputs.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.2,
    question:
      "Write a recursive function in Java to generate all permutations of a given string.",
    code: "public void permute(String s, int left, int right) {\n    if (left == right)\n        System.out.println(s);\n    else {\n        for (int i = left; i <= right; i++) {\n            s = swap(s, left, i);\n            permute(s, left + 1, right);\n            s = swap(s, left, i);\n        }\n    }\n}\n\nprivate String swap(String s, int i, int j) {\n    char[] charArray = s.toCharArray();\n    char temp = charArray[i];\n    charArray[i] = charArray[j];\n    charArray[j] = temp;\n    return String.valueOf(charArray);\n}",
    answers: [
      "The provided code correctly generates all permutations of the given string.",
      "The provided code contains syntax errors.",
      "The provided code does not handle empty strings.",
      "The provided code will result in a stack overflow for large inputs.",
    ],
    correct: 0,
    explanations: [
      "The provided code correctly implements the permutation generation function using recursion.",
      "This is incorrect because the provided code is syntactically correct.",
      "This is incorrect because the provided code handles permutations correctly.",
      "This is incorrect because the provided code is tail-recursive and won't result in a stack overflow for large inputs.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 120,
    topic: "Recursion",
  },
  {
    difficulty: 0.25,
    question:
      "Implement a recursive function in Java to find the greatest common divisor (GCD) of two integers.",
    code: "public int gcd(int a, int b) {\n    if (b == 0)\n        return a;\n    else\n        return gcd(b, a % b);\n}",
    answers: [
      "The provided code correctly calculates the GCD of two integers.",
      "The provided code contains logical errors.",
      "The provided code does not handle negative integers.",
      "The provided code will result in a stack overflow for large inputs.",
    ],
    correct: 0,
    explanations: [
      "The provided code correctly implements the GCD calculation function using recursion.",
      "This is incorrect because the provided code is logically correct.",
      "This is incorrect because the provided code handles 0 correctly.",
      "This is incorrect because the provided code is tail-recursive and won't result in a stack overflow for large inputs.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.3,
    question:
      "Write a recursive function in Java to generate all possible subsets of a given set.",
    code: "public void generateSubsets(int[] nums, int index, List<Integer> subset, List<List<Integer>> result) {\n    result.add(new ArrayList<>(subset));\n    for (int i = index; i < nums.length; i++) {\n        subset.add(nums[i]);\n        generateSubsets(nums, i + 1, subset, result);\n        subset.remove(subset.size() - 1);\n    }\n}",
    answers: [
      "The provided code correctly generates all possible subsets of the given set.",
      "The provided code contains syntax errors.",
      "The provided code does not handle empty sets.",
      "The provided code will result in a stack overflow for large inputs.",
    ],
    correct: 0,
    explanations: [
      "The provided code correctly implements the subset generation function using recursion.",
      "This is incorrect because the provided code is syntactically correct.",
      "This is incorrect because the provided code handles empty set correctly.",
      "This is incorrect because the provided code is tail-recursive and won't result in a stack overflow for large inputs.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 120,
    topic: "Recursion",
  },
  {
    difficulty: 0.4,
    question:
      "Write a recursive function in Java to find the factorial of a given number.",
    code: "public int factorial(int n) {\n    if (n == 0)\n        return 1;\n    else\n        return n * factorial(n - 1);\n}",
    answers: [
      "The provided code correctly calculates the factorial of a given number.",
      "The provided code contains logical errors.",
      "The provided code does not handle negative numbers.",
      "The provided code will result in a stack overflow for large inputs.",
    ],
    correct: 0,
    explanations: [
      "The provided code correctly implements the factorial function using recursion.",
      "This is incorrect because the provided code is logically correct.",
      "This is incorrect because the provided code handles 0 correctly.",
      "This is incorrect because the provided code is tail-recursive and won't result in a stack overflow for large inputs.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.45,
    question:
      "Implement a recursive function in Java to calculate the sum of all elements in an integer array.",
    code: "public int arraySum(int[] arr, int index) {\n    if (index < 0)\n        return 0;\n    else\n        return arr[index] + arraySum(arr, index - 1);\n}",
    answers: [
      "The provided code correctly calculates the sum of all elements in an integer array.",
      "The provided code contains logical errors.",
      "The provided code does not handle empty arrays.",
      "The provided code will result in a stack overflow for large arrays.",
    ],
    correct: 0,
    explanations: [
      "The provided code correctly implements the array sum function using recursion.",
      "This is incorrect because the provided code is logically correct.",
      "This is incorrect because the provided code handles negative index correctly.",
      "This is incorrect because the provided code is tail-recursive and won't result in a stack overflow for large inputs.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.5,
    question:
      "Write a recursive function in Java to generate all permutations of a given array of integers.",
    code: "public void generatePermutations(int[] arr, int index) {\n    if (index == arr.length - 1) {\n        System.out.println(Arrays.toString(arr));\n        return;\n    }\n    for (int i = index; i < arr.length; i++) {\n        swap(arr, index, i);\n        generatePermutations(arr, index + 1);\n        swap(arr, index, i);\n    }\n}\n\nprivate void swap(int[] arr, int i, int j) {\n    int temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n}",
    answers: [
      "The provided code correctly generates all permutations of a given array of integers.",
      "The provided code contains logical errors.",
      "The provided code does not handle empty arrays.",
      "The provided code will result in a stack overflow for large arrays.",
    ],
    correct: 0,
    explanations: [
      "The provided code correctly implements the permutation generation function using recursion.",
      "This is incorrect because the provided code is logically correct.",
      "This is incorrect because the provided code handles the base case correctly.",
      "This is incorrect because the provided code is tail-recursive and won't result in a stack overflow for large inputs.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 120,
    topic: "Recursion",
  },
  {
    difficulty: 0.55,
    question:
      "Implement a recursive function in Java to find the greatest common divisor (GCD) of two integers.",
    code: "public int gcd(int a, int b) {\n    if (b == 0)\n        return a;\n    else\n        return gcd(b, a % b);\n}",
    answers: [
      "The provided code correctly calculates the greatest common divisor (GCD) of two integers.",
      "The provided code contains logical errors.",
      "The provided code does not handle negative numbers.",
      "The provided code will result in a stack overflow for large inputs.",
    ],
    correct: 0,
    explanations: [
      "The provided code correctly implements the GCD calculation function using recursion.",
      "This is incorrect because the provided code is logically correct.",
      "This is incorrect because the provided code handles the base case correctly.",
      "This is incorrect because the provided code is tail-recursive and won't result in a stack overflow for large inputs.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.6,
    question:
      "Write a recursive function in Java to check if a given string is a palindrome.",
    code: "public boolean isPalindrome(String s) {\n    if (s.length() <= 1)\n        return true;\n    else\n        return s.charAt(0) == s.charAt(s.length() - 1) && isPalindrome(s.substring(1, s.length() - 1));\n}",
    answers: [
      "The provided code correctly checks if the string is a palindrome.",
      "The provided code contains logical errors.",
      "The provided code does not handle empty strings.",
      "The provided code will result in a stack overflow for large inputs.",
    ],
    correct: 0,
    explanations: [
      "The provided code correctly implements the palindrome checking function using recursion.",
      "This is incorrect because the provided code is logically correct.",
      "This is incorrect because the provided code handles the base case correctly.",
      "This is incorrect because the provided code is tail-recursive and won't result in a stack overflow for large inputs.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.35,
    question:
      "Write a recursive function in Java to calculate the sum of all elements in an integer array.",
    code: "public int arraySum(int[] arr, int index) {\n    if (index < 0)\n        return 0;\n    else\n        return arr[index] + arraySum(arr, index - 1);\n}",
    answers: [
      "The provided code correctly calculates the sum of all elements in an integer array.",
      "The provided code contains logical errors.",
      "The provided code does not handle empty arrays.",
      "The provided code will result in a stack overflow for large arrays.",
    ],
    correct: 0,
    explanations: [
      "The provided code correctly implements the array sum function using recursion.",
      "This is incorrect because the provided code is logically correct.",
      "This is incorrect because the provided code handles negative index correctly.",
      "This is incorrect because the provided code is tail-recursive and won't result in a stack overflow for large inputs.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.42,
    question:
      "Implement a recursive function in Java to find the greatest common divisor (GCD) of two integers.",
    code: "public int gcd(int a, int b) {\n    if (b == 0)\n        return a;\n    else\n        return gcd(b, a % b);\n}",
    answers: [
      "The provided code correctly calculates the greatest common divisor (GCD) of two integers.",
      "The provided code contains logical errors.",
      "The provided code does not handle negative numbers.",
      "The provided code will result in a stack overflow for large inputs.",
    ],
    correct: 0,
    explanations: [
      "The provided code correctly implements the GCD calculation function using recursion.",
      "This is incorrect because the provided code is logically correct.",
      "This is incorrect because the provided code handles the base case correctly.",
      "This is incorrect because the provided code is tail-recursive and won't result in a stack overflow for large inputs.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.48,
    question:
      "Write a recursive function in Java to check if a given string is a palindrome.",
    code: "public boolean isPalindrome(String s) {\n    if (s.length() <= 1)\n        return true;\n    else\n        return s.charAt(0) == s.charAt(s.length() - 1) && isPalindrome(s.substring(1, s.length() - 1));\n}",
    answers: [
      "The provided code correctly checks if the string is a palindrome.",
      "The provided code contains logical errors.",
      "The provided code does not handle empty strings.",
      "The provided code will result in a stack overflow for large inputs.",
    ],
    correct: 0,
    explanations: [
      "The provided code correctly implements the palindrome checking function using recursion.",
      "This is incorrect because the provided code is logically correct.",
      "This is incorrect because the provided code handles the base case correctly.",
      "This is incorrect because the provided code is tail-recursive and won't result in a stack overflow for large inputs.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.53,
    question:
      "Implement a recursive function in Java to find the length of the longest increasing subsequence in an array of integers.",
    code: "public int longestIncreasingSubsequence(int[] arr, int index, int prev) {\n    if (index == arr.length)\n        return 0;\n    int include = 0;\n    if (arr[index] > prev)\n        include = 1 + longestIncreasingSubsequence(arr, index + 1, arr[index]);",
    answers: [
      "The provided code correctly calculates the length of the longest increasing subsequence.",
      "The provided code contains logical errors.",
      "The provided code does not handle empty arrays.",
      "The provided code will result in a stack overflow for large arrays.",
    ],
    correct: 0,
    explanations: [
      "The provided code correctly implements the longest increasing subsequence function using recursion.",
      "This is incorrect because the provided code is logically correct.",
      "This is incorrect because the provided code handles the base case correctly.",
      "This is incorrect because the provided code is tail-recursive and won't result in a stack overflow for large inputs.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 120,
    topic: "Recursion",
  },
  {
    difficulty: 0.57,
    question: "Write a recursive function in Java to merge two sorted arrays.",
    code: "public int[] mergeSortedArrays(int[] arr1, int[] arr2, int index1, int index2) {\n    if (index1 == arr1.length)\n        return arr2;\n    else if (index2 == arr2.length)\n        return arr1;\n    int[] merged = new int[arr1.length + arr2.length];\n    if (arr1[index1] < arr2[index2]) {\n        merged[index1 + index2] = arr1[index1];\n        return mergeSortedArrays(arr1, arr2, index1 + 1, index2);\n    }",
    answers: [
      "The provided code correctly merges two sorted arrays.",
      "The provided code contains syntax errors.",
      "The provided code does not handle empty arrays.",
      "The provided code will result in a stack overflow for large inputs.",
    ],
    correct: 0,
    explanations: [
      "The provided code correctly implements the array merging function using recursion.",
      "This is incorrect because the provided code is logically correct.",
      "This is incorrect because the provided code handles the base cases correctly.",
      "This is incorrect because the provided code is tail-recursive and won't result in a stack overflow for large inputs.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 120,
    topic: "Recursion",
  },
  {
    difficulty: 0.4,
    question:
      "Write a recursive function in Java to generate all permutations of a given array of integers.",
    code: "public void generatePermutations(int[] arr, int start, List<List<Integer>> result) {\n    if (start == arr.length) {\n        List<Integer> permutation = new ArrayList<>();\n        for (int num : arr) {\n            permutation.add(num);\n        }\n        result.add(permutation);\n        return;\n    }\n    for (int i = start; i < arr.length; i++) {\n        swap(arr, start, i);\n        generatePermutations(arr, start + 1, result);\n        swap(arr, start, i);\n    }\n}\n\nprivate void swap(int[] arr, int i, int j) {\n    int temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n}",
    answers: [
      "The provided code correctly generates all permutations of the given array of integers.",
      "The provided code contains logical errors.",
      "The provided code does not handle empty arrays.",
      "The provided code will result in a stack overflow for large arrays.",
    ],
    correct: 0,
    explanations: [
      "The provided code correctly implements the permutation generation function using recursion.",
      "This is incorrect because the provided code is logically correct.",
      "This is incorrect because the provided code handles the base case correctly.",
      "This is incorrect because the provided code is tail-recursive and won't result in a stack overflow for large inputs.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 120,
    topic: "Recursion",
  },
  {
    difficulty: 0.45,
    question:
      "Implement a recursive function in Java to generate all possible combinations of a given string.",
    code: "public void generateCombinations(String s, int index, String current, List<String> result) {\n    if (index == s.length()) {\n        result.add(current);\n        return;\n    }\n    generateCombinations(s, index + 1, current + s.charAt(index), result);\n    generateCombinations(s, index + 1, current, result);\n}",
    answers: [
      "The provided code correctly generates all possible combinations of the given string.",
      "The provided code contains logical errors.",
      "The provided code does not handle empty strings.",
      "The provided code will result in a stack overflow for large strings.",
    ],
    correct: 0,
    explanations: [
      "The provided code correctly implements the combination generation function using recursion.",
      "This is incorrect because the provided code is logically correct.",
      "This is incorrect because the provided code handles the base case correctly.",
      "This is incorrect because the provided code is tail-recursive and won't result in a stack overflow for large inputs.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 120,
    topic: "Recursion",
  },
  {
    difficulty: 0.5,
    question:
      "Write a recursive function in Java to generate all possible subsets of a given set.",
    code: "public void generateSubsets(int[] nums, int index, List<Integer> subset, List<List<Integer>> result) {\n    if (index == nums.length) {\n        result.add(new ArrayList<>(subset));\n        return;\n    }\n    subset.add(nums[index]);\n    generateSubsets(nums, index + 1, subset, result);\n    subset.remove(subset.size() - 1);\n    generateSubsets(nums, index + 1, subset, result);\n}",
    answers: [
      "The provided code correctly generates all subsets of the given set.",
      "The provided code contains logical errors.",
      "The provided code does not handle empty sets.",
      "The provided code will result in a stack overflow for large sets.",
    ],
    correct: 0,
    explanations: [
      "The provided code correctly implements the subset generation function using recursion.",
      "This is incorrect because the provided code is logically correct.",
      "This is incorrect because the provided code handles the base case correctly.",
      "This is incorrect because the provided code is tail-recursive and won't result in a stack overflow for large inputs.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 150,
    topic: "Recursion",
  },
  {
    difficulty: 0.55,
    question:
      "Implement a recursive function in Java to generate all valid parentheses combinations for a given n.",
    code: "public void generateParentheses(int n, int open, int close, String current, List<String> result) {\n    if (current.length() == 2 * n) {\n        result.add(current);\n        return;\n    }\n    if (open < n)\n        generateParentheses(n, open + 1, close, current + '(', result);\n    if (close < open)\n        generateParentheses(n, open, close + 1, current + ')', result);\n}",
    answers: [
      "The provided code correctly generates all valid parentheses combinations for a given n.",
      "The provided code contains logical errors.",
      "The provided code does not handle empty input.",
      "The provided code will result in a stack overflow for large inputs.",
    ],
    correct: 0,
    explanations: [
      "The provided code correctly implements the parentheses generation function using recursion.",
      "This is incorrect because the provided code is logically correct.",
      "This is incorrect because the provided code handles the base case correctly.",
      "This is incorrect because the provided code is tail-recursive and won't result in a stack overflow for large inputs.",
    ],
    bloomTaxonomy: "Creating",
    timeTakenSeconds: 150,
    topic: "Recursion",
  },
  {
    difficulty: 0.35,
    question:
      "Analyzing the given Java code snippet, what is the time complexity of the recursive function?",
    code: "public int fibonacci(int n) {\n    if (n <= 1)\n        return n;\n    else\n        return fibonacci(n - 1) + fibonacci(n - 2);\n}",
    answers: ["O(2^n)", "O(n)", "O(log n)", "O(n^2)"],
    correct: 0,
    explanations: [
      "The provided code exhibits exponential time complexity as it recursively calls itself twice for each input until reaching the base case.",
      "This is incorrect because the time complexity of the provided code is exponential.",
      "This is incorrect because the time complexity is not logarithmic.",
      "This is incorrect because the time complexity is not quadratic.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.42,
    question:
      "Analyze the given Java code snippet. What will happen if the input value for the recursive function is negative?",
    code: "public int factorial(int n) {\n    if (n <= 1)\n        return 1;\n    else\n        return n * factorial(n - 1);\n}",
    answers: [
      "The function will return 1 for negative input values.",
      "The function will result in a stack overflow due to infinite recursion.",
      "The function will throw an exception.",
      "The function will return -1 for negative input values.",
    ],
    correct: 0,
    explanations: [
      "The provided code correctly handles negative input values by returning 1 for such cases.",
      "This is incorrect because the function handles negative input values appropriately.",
      "This is incorrect because the function does not throw any exception for negative input values.",
      "This is incorrect because the function returns 1, not -1, for negative input values.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.47,
    question:
      "Analyze the given Java code snippet. What is the base case for the recursive function?",
    code: "public boolean isPalindrome(String s) {\n    if (s.length() <= 1)\n        return true;\n    else\n        return s.charAt(0) == s.charAt(s.length() - 1) && isPalindrome(s.substring(1, s.length() - 1));\n}",
    answers: [
      "The base case is when the length of the string is less than or equal to 1.",
      "The base case is when the length of the string is exactly 1.",
      "The base case is when the length of the string is exactly 2.",
      "The base case is when the string is empty.",
    ],
    correct: 0,
    explanations: [
      "The base case is correctly identified as when the length of the string is less than or equal to 1, indicating either an empty string or a single-character string.",
      "This is incorrect because the base case also includes empty strings.",
      "This is incorrect because the base case includes strings of length 1.",
      "This is incorrect because the base case includes strings of length 1 and empty strings.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.51,
    question:
      "Analyze the given Java code snippet. What is the purpose of the recursive function?",
    code: "public int gcd(int a, int b) {\n    if (b == 0)\n        return a;\n    else\n        return gcd(b, a % b);\n}",
    answers: [
      "The purpose is to calculate the greatest common divisor (GCD) of two integers.",
      "The purpose is to calculate the least common multiple (LCM) of two integers.",
      "The purpose is to calculate the factorial of a given integer.",
      "The purpose is to find the nth term of the Fibonacci sequence.",
    ],
    correct: 0,
    explanations: [
      "The purpose of the provided code is correctly identified as calculating the greatest common divisor (GCD) of two integers.",
      "This is incorrect because the function is not related to calculating the least common multiple (LCM).",
      "This is incorrect because the function is not related to calculating factorials.",
      "This is incorrect because the function is not related to finding Fibonacci numbers.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.56,
    question:
      "Analyze the given Java code snippet. What is the purpose of the recursive function?",
    code: "public void reverseArray(int[] arr, int start, int end) {\n    if (start >= end)\n        return;\n    int temp = arr[start];\n    arr[start] = arr[end];\n    arr[end] = temp;\n    reverseArray(arr, start + 1, end - 1);\n}",
    answers: [
      "The purpose is to reverse an array in-place.",
      "The purpose is to sort an array in ascending order.",
      "The purpose is to compute the factorial of a given number.",
      "The purpose is to find the nth term of the Fibonacci sequence.",
    ],
    correct: 0,
    explanations: [
      "The purpose of the provided code is correctly identified as reversing an array in-place using recursion.",
      "This is incorrect because the function is not related to sorting arrays.",
      "This is incorrect because the function is not related to calculating factorials.",
      "This is incorrect because the function is not related to finding Fibonacci numbers.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.75,
    question:
      "Analyze the given Java code snippet. What is the time complexity of the recursive function?",
    code: "public int fibonacci(int n) {\n    if (n <= 1)\n        return n;\n    else\n        return fibonacci(n - 1) + fibonacci(n - 2);\n}",
    answers: ["O(2^n)", "O(n)", "O(log n)", "O(n^2)"],
    correct: 0,
    explanations: [
      "The provided code exhibits exponential time complexity as it recursively calls itself twice for each input until reaching the base case.",
      "This is incorrect because the time complexity of the provided code is exponential.",
      "This is incorrect because the time complexity is not logarithmic.",
      "This is incorrect because the time complexity is not quadratic.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.78,
    question:
      "Analyze the given Java code snippet. What is the space complexity of the recursive function?",
    code: "public int factorial(int n) {\n    if (n <= 1)\n        return 1;\n    else\n        return n * factorial(n - 1);\n}",
    answers: ["O(n)", "O(log n)", "O(1)", "O(n^2)"],
    correct: 0,
    explanations: [
      "The provided code utilizes O(n) space complexity due to the recursive function calls being stored in the call stack until reaching the base case.",
      "This is incorrect because the space complexity is linear.",
      "This is incorrect because the space complexity is not logarithmic.",
      "This is incorrect because the space complexity is not quadratic.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.8,
    question:
      "Analyze the given Java code snippet. How many recursive calls are made by the function for an input of size n?",
    code: "public int gcd(int a, int b) {\n    if (b == 0)\n        return a;\n    else\n        return gcd(b, a % b);\n}",
    answers: [
      "The number of recursive calls is logarithmic in the input size n.",
      "The number of recursive calls is linear in the input size n.",
      "The number of recursive calls is constant for all input sizes.",
      "The number of recursive calls is exponential in the input size n.",
    ],
    correct: 0,
    explanations: [
      "The number of recursive calls made by the provided code is logarithmic in the input size n, as it reduces the problem size by approximately half with each recursive call.",
      "This is incorrect because the number of recursive calls is not linear.",
      "This is incorrect because the number of recursive calls varies with the input size.",
      "This is incorrect because the number of recursive calls is not exponential.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.82,
    question:
      "Analyze the given Java code snippet. What is the worst-case time complexity of the function?",
    code: "public boolean isPalindrome(String s) {\n    if (s.length() <= 1)\n        return true;\n    else\n        return s.charAt(0) == s.charAt(s.length() - 1) && isPalindrome(s.substring(1, s.length() - 1));\n}",
    answers: ["O(n)", "O(log n)", "O(n^2)", "O(2^n)"],
    correct: 0,
    explanations: [
      "The worst-case time complexity of the provided code is linear, as it iterates through half of the characters in the string to check for palindromicity.",
      "This is incorrect because the time complexity is not logarithmic.",
      "This is incorrect because the time complexity is not quadratic.",
      "This is incorrect because the time complexity is not exponential.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.85,
    question:
      "Analyze the given Java code snippet. What is the space complexity of the function?",
    code: "public int fibonacci(int n) {\n    if (n <= 1)\n        return n;\n    else\n        return fibonacci(n - 1) + fibonacci(n - 2);\n}",
    answers: ["O(n)", "O(log n)", "O(1)", "O(n^2)"],
    correct: 0,
    explanations: [
      "The space complexity of the provided code is linear, as it requires additional memory proportional to the input size to store intermediate results in the call stack.",
      "This is incorrect because the space complexity is not logarithmic.",
      "This is incorrect because the space complexity is not constant.",
      "This is incorrect because the space complexity is not quadratic.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.88,
    question:
      "Analyze the given Java code snippet. What is the time complexity of the recursive function?",
    code: "public int factorial(int n) {\n    if (n <= 1)\n        return 1;\n    else\n        return n * factorial(n - 1);\n}",
    answers: ["O(n)", "O(log n)", "O(1)", "O(n^2)"],
    correct: 0,
    explanations: [
      "The time complexity of the provided code is linear, as the recursive function is called n times until reaching the base case.",
      "This is incorrect because the time complexity is not logarithmic.",
      "This is incorrect because the time complexity is not constant.",
      "This is incorrect because the time complexity is not quadratic.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.85,
    question:
      "Analyze the provided Java code snippet. What is the time complexity of the recursive function?",
    code: "public int fibonacci(int n) {\n    if (n <= 1)\n        return n;\n    else\n        return fibonacci(n - 1) + fibonacci(n - 2);\n}",
    answers: ["O(2^n)", "O(n)", "O(log n)", "O(n^2)"],
    correct: 0,
    explanations: [
      "The provided code exhibits exponential time complexity as it recursively calls itself twice for each input until reaching the base case.",
      "This is incorrect because the time complexity of the provided code is exponential.",
      "This is incorrect because the time complexity is not logarithmic.",
      "This is incorrect because the time complexity is not quadratic.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.88,
    question:
      "Analyze the provided Java code snippet. What is the space complexity of the recursive function?",
    code: "public int factorial(int n) {\n    if (n <= 1)\n        return 1;\n    else\n        return n * factorial(n - 1);\n}",
    answers: ["O(n)", "O(log n)", "O(1)", "O(n^2)"],
    correct: 0,
    explanations: [
      "The provided code utilizes O(n) space complexity due to the recursive function calls being stored in the call stack until reaching the base case.",
      "This is incorrect because the space complexity is not logarithmic.",
      "This is incorrect because the space complexity is not constant.",
      "This is incorrect because the space complexity is not quadratic.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.87,
    question:
      "Analyze the provided Java code snippet. How many recursive calls are made by the function for an input of size n?",
    code: "public int gcd(int a, int b) {\n    if (b == 0)\n        return a;\n    else\n        return gcd(b, a % b);\n}",
    answers: [
      "The number of recursive calls is logarithmic in the input size n.",
      "The number of recursive calls is linear in the input size n.",
      "The number of recursive calls is constant for all input sizes.",
      "The number of recursive calls is exponential in the input size n.",
    ],
    correct: 0,
    explanations: [
      "The number of recursive calls made by the provided code is logarithmic in the input size n, as it reduces the problem size by approximately half with each recursive call.",
      "This is incorrect because the number of recursive calls is not linear.",
      "This is incorrect because the number of recursive calls varies with the input size.",
      "This is incorrect because the number of recursive calls is not exponential.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.89,
    question:
      "Analyze the provided Java code snippet. What is the worst-case time complexity of the function?",
    code: "public boolean isPalindrome(String s) {\n    if (s.length() <= 1)\n        return true;\n    else\n        return s.charAt(0) == s.charAt(s.length() - 1) && isPalindrome(s.substring(1, s.length() - 1));\n}",
    answers: ["O(n)", "O(log n)", "O(n^2)", "O(2^n)"],
    correct: 0,
    explanations: [
      "The worst-case time complexity of the provided code is linear, as it iterates through half of the characters in the string to check for palindromicity.",
      "This is incorrect because the time complexity is not logarithmic.",
      "This is incorrect because the time complexity is not quadratic.",
      "This is incorrect because the time complexity is not exponential.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.86,
    question:
      "Analyze the provided Java code snippet. What is the space complexity of the function?",
    code: "public int fibonacci(int n) {\n    if (n <= 1)\n        return n;\n    else\n        return fibonacci(n - 1) + fibonacci(n - 2);\n}",
    answers: ["O(n)", "O(log n)", "O(1)", "O(n^2)"],
    correct: 0,
    explanations: [
      "The space complexity of the provided code is linear, as it requires additional memory proportional to the input size to store intermediate results in the call stack.",
      "This is incorrect because the space complexity is not logarithmic.",
      "This is incorrect because the space complexity is not constant.",
      "This is incorrect because the space complexity is not quadratic.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.87,
    question:
      "Analyze the provided Java code snippet. What is the time complexity of the recursive function?",
    code: "public int factorial(int n) {\n    if (n <= 1)\n        return 1;\n    else\n        return n * factorial(n - 1);\n}",
    answers: ["O(n)", "O(log n)", "O(1)", "O(n^2)"],
    correct: 0,
    explanations: [
      "The time complexity of the provided code is linear, as the recursive function is called n times until reaching the base case.",
      "This is incorrect because the time complexity is not logarithmic.",
      "This is incorrect because the time complexity is not constant.",
      "This is incorrect because the time complexity is not quadratic.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.92,
    question:
      "Analyze the following Java code snippet. What is the time complexity of the recursive function?",
    code: "public int fibonacci(int n) {\n    if (n <= 1)\n        return n;\n    else\n        return fibonacci(n - 1) + fibonacci(n - 2);\n}",
    answers: ["O(2^n)", "O(n)", "O(log n)", "O(n^2)"],
    correct: 0,
    explanations: [
      "The provided code exhibits exponential time complexity as it recursively calls itself twice for each input until reaching the base case.",
      "This is incorrect because the time complexity of the provided code is exponential.",
      "This is incorrect because the time complexity is not logarithmic.",
      "This is incorrect because the time complexity is not quadratic.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.94,
    question:
      "Analyze the following Java code snippet. What is the space complexity of the recursive function?",
    code: "public int factorial(int n) {\n    if (n <= 1)\n        return 1;\n    else\n        return n * factorial(n - 1);\n}",
    answers: ["O(n)", "O(log n)", "O(1)", "O(n^2)"],
    correct: 0,
    explanations: [
      "The provided code utilizes O(n) space complexity due to the recursive function calls being stored in the call stack until reaching the base case.",
      "This is incorrect because the space complexity is not logarithmic.",
      "This is incorrect because the space complexity is not constant.",
      "This is incorrect because the space complexity is not quadratic.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.93,
    question:
      "Analyze the following Java code snippet. How many recursive calls are made by the function for an input of size n?",
    code: "public int gcd(int a, int b) {\n    if (b == 0)\n        return a;\n    else\n        return gcd(b, a % b);\n}",
    answers: [
      "The number of recursive calls is logarithmic in the input size n.",
      "The number of recursive calls is linear in the input size n.",
      "The number of recursive calls is constant for all input sizes.",
      "The number of recursive calls is exponential in the input size n.",
    ],
    correct: 0,
    explanations: [
      "The number of recursive calls made by the provided code is logarithmic in the input size n, as it reduces the problem size by approximately half with each recursive call.",
      "This is incorrect because the number of recursive calls is not linear.",
      "This is incorrect because the number of recursive calls varies with the input size.",
      "This is incorrect because the number of recursive calls is not exponential.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.95,
    question:
      "Analyze the following Java code snippet. What is the worst-case time complexity of the function?",
    code: "public boolean isPalindrome(String s) {\n    if (s.length() <= 1)\n        return true;\n    else\n        return s.charAt(0) == s.charAt(s.length() - 1) && isPalindrome(s.substring(1, s.length() - 1));\n}",
    answers: ["O(n)", "O(log n)", "O(n^2)", "O(2^n)"],
    correct: 0,
    explanations: [
      "The worst-case time complexity of the provided code is linear, as it iterates through half of the characters in the string to check for palindromicity.",
      "This is incorrect because the time complexity is not logarithmic.",
      "This is incorrect because the time complexity is not quadratic.",
      "This is incorrect because the time complexity is not exponential.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.91,
    question:
      "Analyze the following Java code snippet. What is the space complexity of the function?",
    code: "public int fibonacci(int n) {\n    if (n <= 1)\n        return n;\n    else\n        return fibonacci(n - 1) + fibonacci(n - 2);\n}",
    answers: ["O(n)", "O(log n)", "O(1)", "O(n^2)"],
    correct: 0,
    explanations: [
      "The space complexity of the provided code is linear, as it requires additional memory proportional to the input size to store intermediate results in the call stack.",
      "This is incorrect because the space complexity is not logarithmic.",
      "This is incorrect because the space complexity is not constant.",
      "This is incorrect because the space complexity is not quadratic.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.92,
    question:
      "Analyze the following Java code snippet. What is the time complexity of the recursive function?",
    code: "public int factorial(int n) {\n    if (n <= 1)\n        return 1;\n    else\n        return n * factorial(n - 1);\n}",
    answers: ["O(n)", "O(log n)", "O(1)", "O(n^2)"],
    correct: 0,
    explanations: [
      "The time complexity of the provided code is linear, as the recursive function is called n times until reaching the base case.",
      "This is incorrect because the time complexity is not logarithmic.",
      "This is incorrect because the time complexity is not constant.",
      "This is incorrect because the time complexity is not quadratic.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.85,
    question:
      "Evaluate the given Java code snippet. What will be the output of the function call for input 5?",
    code: "public int factorial(int n) {\n    if (n <= 1)\n        return 1;\n    else\n        return n * factorial(n - 1);\n}\n\nSystem.out.println(factorial(5));",
    answers: ["120", "24", "720", "5040"],
    correct: 0,
    explanations: [
      "The function computes the factorial of 5, which equals 120.",
      "This is incorrect because it doesn't match the actual output of the function call.",
      "This is incorrect because it doesn't match the actual output of the function call.",
      "This is incorrect because it doesn't match the actual output of the function call.",
    ],
    bloomTaxonomy: "Evaluating",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.88,
    question:
      "Evaluate the given Java code snippet. What will be the output of the function call for input 4?",
    code: "public int fibonacci(int n) {\n    if (n <= 1)\n        return n;\n    else\n        return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\nSystem.out.println(fibonacci(4));",
    answers: ["3", "5", "8", "13"],
    correct: 0,
    explanations: [
      "The function computes the 4th Fibonacci number, which is 3.",
      "This is incorrect because it doesn't match the actual output of the function call.",
      "This is incorrect because it doesn't match the actual output of the function call.",
      "This is incorrect because it doesn't match the actual output of the function call.",
    ],
    bloomTaxonomy: "Evaluating",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.86,
    question:
      "Evaluate the given Java code snippet. What will be the output of the function call for input 3?",
    code: "public int gcd(int a, int b) {\n    if (b == 0)\n        return a;\n    else\n        return gcd(b, a % b);\n}\n\nSystem.out.println(gcd(12, 8));",
    answers: ["4", "8", "12", "24"],
    correct: 0,
    explanations: [
      "The function computes the greatest common divisor of 12 and 8, which is 4.",
      "This is incorrect because it doesn't match the actual output of the function call.",
      "This is incorrect because it doesn't match the actual output of the function call.",
      "This is incorrect because it doesn't match the actual output of the function call.",
    ],
    bloomTaxonomy: "Evaluating",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.9,
    question:
      'Evaluate the given Java code snippet. What will be the output of the function call for input "racecar"?',
    code: 'public boolean isPalindrome(String s) {\n    if (s.length() <= 1)\n        return true;\n    else\n        return s.charAt(0) == s.charAt(s.length() - 1) && isPalindrome(s.substring(1, s.length() - 1));\n}\n\nSystem.out.println(isPalindrome("racecar"));',
    answers: ["true", "false", "Error", "racecar"],
    correct: 0,
    explanations: [
      "The function checks if the input string is a palindrome, which it is, so the output is true.",
      "This is incorrect because it doesn't match the actual output of the function call.",
      "This is incorrect because it doesn't match the actual output of the function call.",
      "This is incorrect because it doesn't match the actual output of the function call.",
    ],
    bloomTaxonomy: "Evaluating",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.92,
    question:
      "Evaluate the given Java code snippet. What will be the output of the function call for input 3?",
    code: "public int fibonacci(int n) {\n    if (n <= 1)\n        return n;\n    else\n        return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\nSystem.out.println(fibonacci(3));",
    answers: ["2", "3", "5", "8"],
    correct: 0,
    explanations: [
      "The function computes the 3rd Fibonacci number, which is 2.",
      "This is incorrect because it doesn't match the actual output of the function call.",
      "This is incorrect because it doesn't match the actual output of the function call.",
      "This is incorrect because it doesn't match the actual output of the function call.",
    ],
    bloomTaxonomy: "Evaluating",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.94,
    question:
      "Evaluate the given Java code snippet. What will be the output of the function call for input 5?",
    code: "public int factorial(int n) {\n    if (n <= 1)\n        return 1;\n    else\n        return n * factorial(n - 1);\n}\n\nSystem.out.println(factorial(5));",
    answers: ["120", "24", "720", "5040"],
    correct: 0,
    explanations: [
      "The function computes the factorial of 5, which equals 120.",
      "This is incorrect because it doesn't match the actual output of the function call.",
      "This is incorrect because it doesn't match the actual output of the function call.",
      "This is incorrect because it doesn't match the actual output of the function call.",
    ],
    bloomTaxonomy: "Evaluating",
    timeTakenSeconds: 90,
    topic: "Recursion",
  },
  {
    difficulty: 0.6,
    question:
      "Evaluate the following Java code snippet. What will be the output of the function call for input 3?",
    code: "public int factorial(int n) {\n    if (n <= 1)\n        return 1;\n    else\n        return n * factorial(n - 1);\n}\n\nSystem.out.println(factorial(3));",
    answers: ["6", "3", "9", "12"],
    correct: 0,
    explanations: [
      "The function computes the factorial of 3, which equals 6.",
      "This is incorrect because it doesn't match the actual output of the function call.",
      "This is incorrect because it doesn't match the actual output of the function call.",
      "This is incorrect because it doesn't match the actual output of the function call.",
    ],
    bloomTaxonomy: "Evaluating",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.55,
    question:
      "Evaluate the given Java code snippet. What will be the output of the function call for input 4?",
    code: "public int fibonacci(int n) {\n    if (n <= 1)\n        return n;\n    else\n        return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\nSystem.out.println(fibonacci(4));",
    answers: ["3", "5", "8", "13"],
    correct: 0,
    explanations: [
      "The function computes the 4th Fibonacci number, which is 3.",
      "This is incorrect because it doesn't match the actual output of the function call.",
      "This is incorrect because it doesn't match the actual output of the function call.",
      "This is incorrect because it doesn't match the actual output of the function call.",
    ],
    bloomTaxonomy: "Evaluating",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.65,
    question:
      "Evaluate the given Java code snippet. What will be the output of the function call for input 5?",
    code: "public int gcd(int a, int b) {\n    if (b == 0)\n        return a;\n    else\n        return gcd(b, a % b);\n}\n\nSystem.out.println(gcd(12, 8));",
    answers: ["4", "8", "12", "24"],
    correct: 0,
    explanations: [
      "The function computes the greatest common divisor of 12 and 8, which is 4.",
      "This is incorrect because it doesn't match the actual output of the function call.",
      "This is incorrect because it doesn't match the actual output of the function call.",
      "This is incorrect because it doesn't match the actual output of the function call.",
    ],
    bloomTaxonomy: "Evaluating",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.7,
    question:
      'Evaluate the given Java code snippet. What will be the output of the function call for input "racecar"?',
    code: 'public boolean isPalindrome(String s) {\n    if (s.length() <= 1)\n        return true;\n    else\n        return s.charAt(0) == s.charAt(s.length() - 1) && isPalindrome(s.substring(1, s.length() - 1));\n}\n\nSystem.out.println(isPalindrome("racecar"));',
    answers: ["true", "false", "Error", "racecar"],
    correct: 0,
    explanations: [
      "The function checks if the input string is a palindrome, which it is, so the output is true.",
      "This is incorrect because it doesn't match the actual output of the function call.",
      "This is incorrect because it doesn't match the actual output of the function call.",
      "This is incorrect because it doesn't match the actual output of the function call.",
    ],
    bloomTaxonomy: "Evaluating",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.55,
    question:
      "Evaluate the given Java code snippet. What will be the output of the function call for input 3?",
    code: "public int fibonacci(int n) {\n    if (n <= 1)\n        return n;\n    else\n        return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\nSystem.out.println(fibonacci(3));",
    answers: ["2", "3", "5", "8"],
    correct: 0,
    explanations: [
      "The function computes the 3rd Fibonacci number, which is 2.",
      "This is incorrect because it doesn't match the actual output of the function call.",
      "This is incorrect because it doesn't match the actual output of the function call.",
      "This is incorrect because it doesn't match the actual output of the function call.",
    ],
    bloomTaxonomy: "Evaluating",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.6,
    question:
      "Evaluate the given Java code snippet. What will be the output of the function call for input 5?",
    code: "public int factorial(int n) {\n    if (n <= 1)\n        return 1;\n    else\n        return n * factorial(n - 1);\n}\n\nSystem.out.println(factorial(5));",
    answers: ["120", "24", "720", "5040"],
    correct: 0,
    explanations: [
      "The function computes the factorial of 5, which equals 120.",
      "This is incorrect because it doesn't match the actual output of the function call.",
      "This is incorrect because it doesn't match the actual output of the function call.",
      "This is incorrect because it doesn't match the actual output of the function call.",
    ],
    bloomTaxonomy: "Evaluating",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.5,
    question:
      "Consider the following recursive function in Java:\n\n```\npublic int factorial(int n) {\n    if (n == 0)\n        return 1;\n    else\n        return n * factorial(n - 1);\n}\n```\n\nWhat is the base case of this function?",
    answers: ["n == 0", "n == 1", "n <= 1", "n <= 0"],
    correct: 0,
    explanations: [
      "The base case of the factorial function is when n equals 0, as it returns 1.",
      "This is incorrect. The base case is when n equals 0, not 1.",
      "This is incorrect. The base case is when n equals 0, not when n is less than or equal to 1.",
      "This is incorrect. The base case is when n equals 0, not when n is less than or equal to 0.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.4,
    question: "What is the purpose of a base case in a recursive function?",
    answers: [
      "To provide a termination condition for the recursion.",
      "To increase the efficiency of the function.",
      "To allow the function to handle larger inputs.",
      "To reduce the memory usage of the function.",
    ],
    correct: 0,
    explanations: [
      "The base case provides a termination condition for the recursion, ensuring that the function stops calling itself recursively.",
      "This is incorrect. The base case does not directly affect the efficiency of the function.",
      "This is incorrect. The base case does not affect the input size the function can handle.",
      "This is incorrect. The base case does not directly affect the memory usage of the function.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 45,
    topic: "Recursion",
  },
  {
    difficulty: 0.4,
    question: "What happens if a recursive function does not have a base case?",
    answers: [
      "It will result in infinite recursion.",
      "It will terminate immediately.",
      "It will return an error.",
      "It will execute only once.",
    ],
    correct: 0,
    explanations: [
      "Without a base case, the recursive function will continue to call itself indefinitely, resulting in infinite recursion.",
      "This is incorrect. Without a base case, the function does not terminate immediately.",
      "This is incorrect. Without a base case, the function does not necessarily return an error.",
      "This is incorrect. Without a base case, the function does not necessarily execute only once.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 45,
    topic: "Recursion",
  },
  {
    difficulty: 0.5,
    question:
      "In a recursive function, what is typically done in the recursive step?",
    answers: [
      "The function calls itself with a modified input.",
      "The function returns the result immediately.",
      "The function performs an iterative loop.",
      "The function evaluates the base case.",
    ],
    correct: 0,
    explanations: [
      "In the recursive step, the function calls itself with a modified input, moving towards the base case.",
      "This is incorrect. The recursive step involves calling the function itself again, not returning the result immediately.",
      "This is incorrect. Recursive functions do not typically involve iterative loops within the function.",
      "This is incorrect. The recursive step is separate from evaluating the base case.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.4,
    question:
      "What is the significance of the stack in recursive function execution?",
    answers: [
      "It keeps track of function calls and their local variables.",
      "It stores the base case of the function.",
      "It ensures that the function always returns a value.",
      "It manages the iteration of the recursive function.",
    ],
    correct: 0,
    explanations: [
      "The stack keeps track of function calls and their local variables, allowing for the management of recursive function execution.",
      "This is incorrect. The stack does not store the base case of the function.",
      "This is incorrect. The stack's role is not related to ensuring the function always returns a value.",
      "This is incorrect. The stack's role is not related to managing the iteration of the recursive function.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 45,
    topic: "Recursion",
  },
  {
    difficulty: 0.5,
    question:
      "What does it mean if a recursive function exhibits tail recursion?",
    answers: [
      "The recursive call is the last operation performed by the function.",
      "The function has multiple base cases.",
      "The function returns a value without any recursive calls.",
      "The function does not have a base case.",
    ],
    correct: 0,
    explanations: [
      "In tail recursion, the recursive call is the last operation performed by the function before returning, optimizing memory usage.",
      "This is incorrect. Tail recursion does not imply having multiple base cases.",
      "This is incorrect. Tail recursion involves recursive calls, not immediate return values.",
      "This is incorrect. Tail recursion still requires a base case.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 60,
    topic: "Recursion",
  },
  {
    difficulty: 0.4,
    question:
      "Which of the following statements best describes the concept of recursion?",
    answers: [
      "A function calls itself directly or indirectly in order to solve a problem.",
      "A function repeats a set of instructions for a specified number of times.",
      "A function uses a loop construct to execute a set of instructions.",
      "A function returns a value based on a condition.",
    ],
    correct: 0,
    explanations: [
      "Recursion involves a function calling itself directly or indirectly to solve a problem, often involving smaller instances of the same problem.",
      "This is incorrect. Recursion is not about repeating a set of instructions a specified number of times.",
      "This is incorrect. Recursion does not necessarily involve loop constructs.",
      "This is incorrect. Recursion is not solely based on returning a value based on a condition.",
    ],
    bloomTaxonomy: "Analyzing",
    timeTakenSeconds: 45,
    topic: "Recursion",
  },
];
